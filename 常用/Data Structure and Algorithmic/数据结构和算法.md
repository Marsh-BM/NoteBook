#   数据结构和算法

## 数据结构和算法的关系

1. 数据data结构是一门研究**组织数据**方法的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出 更加漂亮，更加有效率的代码。
2. 程序 = 数据结构+算法
3. 注意：**数据结构是算法的基础**

 ## 数据结构

### 线性结构

1. 线性结构是最常用的数据结构，其特点是数据元素间存在**一对一**的线性关系。
2. 线性结构有两种不同的存储结构，即**顺序存储结构**（数组）和**链式存储结构**（链表）。顺序存储的线性表称为**顺序表**，顺序表中的存储元素是连续的
3. 链式存储的线性表被称为**链表**，链表中存储的元素不一定是连续的，元素节点中存放数据的元素以及相邻元素的**地址信息**。
4. 线性结构常见的有：数组，队列，链表和栈等等。

### 非线性结构

1. 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构。

## 稀疏数组

基本介绍：当一个数组中大部分元素为0，或者为同一个值的数组的时候，可以用稀疏数组来保存该数组。（占用内存更少）

![image-20220312144059297](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220312144059297.png)

### 处理方法

1. 记录一个数组有几行几列，有多少个不同的值。
2. 把不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。

### 应用实例

棋盘-二维数组-稀疏数组之间的相互转换。

![image-20220312170631283](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220312170631283.png)

  关于二维数组转换为稀疏数组的思路

1. 遍历原始的二维数组，得到有效数据的个数sum。
2. 根据sum创造出相应的稀疏数组sparseArray int[sum+1] [3].
3. 将二维数组的有效数据存入到稀疏数组中。

稀疏数组转换为原始的二维数组的思路

1. 首先读取稀疏数组的第一行，根据第一行的数据，创建出原始的二维数组，比如上面的 chessArr = int[11] [11].
2. 读取稀疏数组的之后存储有效数据的行，并赋给原始的二维数组即可。

### 代码实现

```
/**
 * @author 巩泽楷
 * @version 1.0
 * 稀疏数组的代码实现。
 */
public class SparseArray {
    public static void main(String[] args) {
        //创建原始的二维数组，11*11
        //0,没有棋子.1，黑子。2，白子。
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        //输出最原始的二维数组。
        for (int[] row : chessArr1) {
            for (int data :row) {
                System.out.print(data+"\t");
            }
            System.out.println();
        }

        //将二维数组转换为稀疏数组
        //1.首先，得到二维数组中所有的无效数据，即为0的个数。
        int sum = 0;
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j]!=0){
                    sum++;
                }
            }
        }
        //2.创建对应的稀疏数组。
        int sparseArr[][]=new int[sum+1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        //遍历二维数组，将非0的值存放到存放到稀疏数组中。
        int count = 0;  //用于记录第几个非0数据。
        for (int i = 0; i < 11; i++) {
            for (int j = 0; j < 11; j++) {
                if (chessArr1[i][j]!=0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        //输出稀疏数组。
        //1.增强for循环
        System.out.println("增强for循环：");
        for (int[] row :sparseArr) {
            for (int data :row) {
                System.out.print(data+"\t");
            }
            System.out.println();
        }

        //2.for循环
        System.out.println("for循环：");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.print(sparseArr[i][0]+"\t"+sparseArr[i][1]+"\t"+sparseArr[i][2]);
            System.out.println();
        }
        System.out.println();
        //下面是将稀疏数组转换为二维数组。
        //1.读取稀疏数组的第一行，根据第一行的数据，创建二维数组。
        int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        //遍历稀疏数组，将稀疏数组中的数放入二维数组。
        for (int i = 1; i < sparseArr.length; i++) {
            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        //输出第二数组
        System.out.println("输出第二数组：");
        for (int[] row : chessArr1) {
            for (int data :row) {
                System.out.print(data+"\t");
            }
            System.out.println();
        }


    }
}
```

## 队列

* 队列是一个有序列表，可以用数组或者链表来实现。
* 遵守先入先出的原则。即：先存入的数据，先取出。（与栈相反。）
* 示意图：

![image-20220312191302005](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220312191302005.png)

* 队列本身是有序的列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图，其中maxSize是该队列的最大容量。
* 因为队列的输出，输入是依靠前后端来处理，因此需要两个变量front以及rear分别记录队列前后端以及下标，front会随着数据的输出而改变，而rear则是随着数据的输入而改变。
* 如上图所示。

### 数组模拟队列

当我们将数据存入的队列称为“addQueue”，addQueue的处理需要有两个步骤。

1. 将尾指针往后移：rear+1，当front == rear	【null】
2. 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear == maxSize【队列满】

#### 代码示例：

```
import java.util.Scanner;
/**
 * @author 巩泽楷
 * @version 1.0
 * 利用数组模拟队列的实现
 * 但是下面代码的缺陷在于栈无法重复使用。
 */
public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key = ' ';//接收用户的输入。
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出队列");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列中取出数据");
            System.out.println("h(head):查看队列的头数据");
            key = scanner.next().charAt(0); //接受一个字符。
            switch (key){
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入一个字符");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = arrayQueue.getQueue();
                        System.out.println("取出的数据是："+res);
                    } catch(Exception e){
                        System.out.println(e.getMessage()/* getMessage的作用是获取异常信息。 */);
                    }
                    break;
                case 'h':
                    try{
                        int res = arrayQueue.headQueue();
                        System.out.println("取出的头数据是："+res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }
}
class ArrayQueue{
    private int maxSize;    //表示数组的最大容量。
    private int front;      //队列头
    private int rear;       //队列尾
    private int[] arr;      //该数组用于存放数据，模拟队列

    //创建构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; //赋值为-1是因为front指向队列的头部的前一个位置。
        rear = -1;  //赋值为-1是因为front指向队列的尾部的数据（包含尾部的最后一个数据）。
    }
    //判断队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("队列已满，不能加入新的数据。");
            return;
        }else{
            rear++;
            arr[rear] = n;
        }
    }
    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能取出数据。");
        }else{
            front++;
            return arr[front];
        }
    }
    public void showQueue(){
        if (isEmpty()){
            System.out.println("队列为空，没有数据");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
    //显示队列的头数据
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能取出数据。");
        }else{
            front++;
            return arr[front];
        }
    }
}
```

* 但是上述代码的问题是只能使用一次。因为front可以从-1到3但无法退从3到-1。无法达到复用的效果
* 我们可以使用算法，将其改造成一个环形的队列。

### 数组模拟环形队列

1. front 变量的含义进行调整： front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素。（或者说从0开始，front的初始值为0）
2. rear变量的含义进行调整：rear指向队列的最后一个元素的最后一个位置。也就是说，**当Maxsize = n时，队列满时，rear指向n-1。**因为希望空出一个空间做约定。故rear的初始值为0.
3. 当队列满时，条件（rear+1）%maxSize = front【满】
4. 当队列为空时，rear = front【空】
5. 当我们这样分析，队列中有效的数据的个数 <font size=3 color ="red">（rear + maxSize-front）%maxSize </font>//rear =1 front =0
6. 通过这个就可以得到一个环形队列。因为是环形数组，要保证在front不等于0的情况下（即有数据被取出时），rear可以将数据添加到被取出数据的位置。所以代码要有所改变。

 #### 代码实例

```
import java.util.Scanner;

/**
 * @author 巩泽楷
 * @version 1.0
 * 代码实现环形队列
 */
public class CircleArrayQueue {
    public static void main(String[] args) {
        //测试数组模拟环形队列
        CircleArray arrayQueue = new CircleArray(3);
        char key = ' ';//接收用户的输入。
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop){
            System.out.println("s(show):显示队列");
            System.out.println("e(exit):退出队列");
            System.out.println("a(add):添加数据到队列");
            System.out.println("g(get):从队列中取出数据");
            System.out.println("h(head):查看队列的头数据");
            key = scanner.next().charAt(0); //接受一个字符。
            switch (key){
                case 's':
                    arrayQueue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入一个字符");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try{
                        int res = arrayQueue.getQueue();
                        System.out.println("取出的数据是："+res);
                    } catch(Exception e){
                        System.out.println(e.getMessage()/* getMessage的作用是获取异常信息。 */);
                    }
                    break;
                case 'h':
                    try{
                        int res = arrayQueue.headQueue();
                        System.out.println("取出的头数据是："+res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");

    }
}

class CircleArray{
    private int maxSize;    //表示数组的最大容量。
    private int front;      //队列头
    private int rear;       //队列尾
    private int[] arr;      //该数组用于存放数据，模拟队列

    //构造器
    public CircleArray(int arrMaxSize){
        maxSize =arrMaxSize;
        arr = new int[maxSize];
    }
    //判断队列是否满
    public boolean isFull(){
        return (rear+1)%maxSize == front;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("队列已满，不能加入新的数据。");
            return;
        }
        //直接加入数据
        arr[rear] = n;
        //取余的目的在于保证达到环形队列。
        rear = (rear+1)%maxSize;
    }

    public int getQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能取出数据。");
        }else{
            //1.先将front的值保留到某个临时变量之中。
            //2.将front后移，考虑取模。
            //3.将临时保存的变量返回。
            int value = arr[front];
            //取出过程中浪费了一个空间，maxSize的位置不会存在
            front = (front+1)%maxSize;
            return value;
        }
    }

    public void showQueue(){
        if (isEmpty()){
            System.out.println("队列为空，没有数据");
            return;
        }
        //变成环形队列后，不能按照arr.length的方式进行遍历。
        //所以，我们应从front开始，遍历有效元素的个数
        //取余的目的是完成环形队列
        for (int i = front; i < front+size(); i++) {
            System.out.println("arr["+(i%maxSize)+"]:"+arr[i%maxSize]);
        }
    }
    public int size(){
        return (rear +maxSize-front)%maxSize;
    }

    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空，不能取出数据。");
        }else{
            return arr[front];
        }
    }
}
```

## 链表（Linked List）

1. 链表是以节点的方式来存储

2. 每个节点包含data域，next域：指向下一个节点。

3. 如图：发现链表的各个节点不一定连续存储。

4. 链表分为有头节点的链表和没有头节点的链表。

   ![image-20220315121004188](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220315121004188.png)

​	逻辑结构

![image-20220315121323755](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220315121323755.png)

#### 代码实例

思路：

![image-20220315150840158](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220315150840158.png)

* 下面代码的缺陷是只能按照添加顺序进行排序，不能按照编号或者其他方式进行排序。

代码

```
package LinkedList;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class SingleLinkedListDemo {
    public static void main(String[] args) {

    }
}
//用于管理HeroNode
class SingleLinkedList{
    //先初始化一个头节点，头节点不要动，不存放具体数据
    private HeroNode head = new HeroNode(0,"","");

    //添加节点到单向链表
    //思路：当不考虑当前编号顺序时，
    //1.找到当前链表的最后节点。
    //2.将最后这个节点的next指向新的节点。
    public void add(HeroNode heroNode){
        //因为head节点不能动，因此需要一个对象来辅助遍历
        HeroNode temp = head;
        //遍历链表，找到最后
        while(true){
            if (temp.next == null){
                break;  //退出循环
            }
            temp = temp.next;
        }
        //当退出循环时，temp就指向了链表的最后
        //此时，temp.next应当指向被添加的节点
        temp.next = heroNode;
    }
    //显示链表
    public void list(){
        //判断链表是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode temp = head.next;
        while(true){
           //判断链表是否到了最后
           if (temp == null){
               break;
           }
            System.out.println(temp);
           temp = temp.next;
        }

    }
}
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    public HeroNode next;   //下一个节点
    //constructor

    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                ", next=" + next +
                '}';
    }
}
```

### 按照特定顺序添加

```
//按顺序加入链表
public void addByOrder(HeroNode heroNode){
    //与上面的方法类似，使用temp来查找添加的位置。
    HeroNode temp = head;
    boolean flag = false;
    while (true){
        if (temp.next == null){
            break;
        }
        if (temp.next.no > heroNode.no){
            break;
        }
        if (temp.no == heroNode.no){
            flag = true;//说明添加的编号已经存在
            break;
        }
        temp = temp.next;
    }
    if (flag){
        System.out.println("编号"+heroNode.no+"已经存在，不能加入");
    } else {
        heroNode.next = temp.next;
        temp.next = heroNode;
    }
}
```

### 单向链表的修改

* 思路1.用遍历找到需要修改的节点编号2.对于相应节点进行修改

* 代码如下：

  ```
  //修改节点的信息，根据no的编号进行修改
  public void update(HeroNode newHeroNode){
      //判断是否为空
      if (head.next ==null){
          System.out.println("该列表为空。");
          return;
      }
      //根据no的编号，找到需要修改的节点。
      HeroNode temp = head.next;
      boolean flag = false;
      while (true){
          if(temp == null){
              break;
          }
          if (temp.no == newHeroNode.no){
              flag = true;
              break;
          }
          temp = temp.next;
      }
      //判断是否找到
      if (flag){
          temp.name = newHeroNode.name;
          temp.nickname = newHeroNode.nickname;
      }else {
          System.out.println("没有找到相应的编号。");
      }
  }
  ```

### 单向链表节点的删除

* 思路：1.找到需要删除的节点。2.改变需要删除节点前面一个节点的next值。3.被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收。

* 代码实例：

  ```
  //删除节点
  //思路：
  //1.找到需要删除的节点。
  //2.改变需要删除节点前面一个节点的next值。
  //3.被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收。
  public void del(int no){        //按照编号删除
      HeroNode temp = head;   //删除目标的前一个节点
      boolean flag = false;
      //判断
      while (true){
          //判断是否为空
          if (temp.next == null){
              break;
          }
          if (temp.next.no == no){
              //找到的待删除节点的前一个temp
              flag = true;
              break;
          }
          temp =temp.next;
      }
      //执行
      if (flag){
          temp.next = temp.next.next;
      }else {
          System.out.println("要删除的节点不存在。");
      }
  }
  
  ```

### 单链表的面试题

1. 求单链表中有效节点的个数

   ```
   //获取单链表的有效节点个数（如果是带头结点的链表，不考虑头节点）
   /**
    * head 表示头节点
    * return 返回的就是有效节点的个数。
    */
   public static int getLength(HeroNode head){
       //首先，判断是否为空
       if (head.next == null){
           return 0;
       }else {
           int length = 0;
           //定义一个辅助的变量
           HeroNode cur = head.next;
           while (cur!=null){
               length++;
               cur = cur.next; //遍历
           }
           return length;
       }
   }
   ```

2. 查找单链表的倒数第k个节点

   ```
    /**
        * 查找单链表的倒数第k个节点
        * index为倒数第几个节点
        * node为头节点！！！！
        * 1.首先正常遍历得出有效节点数
        * 2.length-index为倒数第几个节点
        */
       public static HeroNode findLastIndexNode(HeroNode head, int index){
           //判断链表为空
           if (head.next == null){
               System.out.println("单向链表为空，无法找到");
               return null;
           }
           int length = getLength(head);
           //校验index
           if (index<0||index>length){
               return null;
           }
           HeroNode temp = head.next;
           for (int i = 0; i < length-index; i++) {
               temp = temp.next;
           }
           return temp;
       }
   }
   ```

3. 单链表的反转（头节点不变）

* 思路：1.定义一个节点reverseHead = new HeroNode();2.从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端。3.原来的链表的head.next = reverHead.next。

```
//单链表反转
public static void reverseList(HeroNode head){
    //如果当前链表为空或只有一个节点，直接返回
    if (head.next == null || head.next.next == null){
        return;
    }
    //当链表不只一个的时候，先遍历
    HeroNode temp = head.next;
    HeroNode node = null;
    HeroNode reverseHead = new HeroNode(0,"","");
    while (temp!=null){
        node = temp.next;
        reverseHead.next = temp.next;//将cur的下一个节点指向新的节点的最前端
        temp = node;
    }
    //将原有代码的头节点指向重新形成的节点。
    reverseHead.next = head.next;
}
```

4. 反向打印单链表【要求方式1.反向遍历。2.Stack栈】

* 思路：因为栈的特点是先进后出，所以要把节点压进栈然后反向遍历出反向链表。

```
//使用反向链表和栈从头到尾打印链表
public static void reversePrint(HeroNode head){
    if (head.next==null){
        return;
    }
    //创建一个栈，并且将各个节点压入这个栈
    Stack<HeroNode> stack = new Stack<HeroNode>();
    HeroNode cur = head.next;
    //将所有的链表压入栈
    while(cur != null){
        stack.push(cur);
        cur = cur.next;
    }
    //遍历取出栈中的数据
    while (stack.size()>0){
        System.out.println(stack.pop());
    }
}
```

5. 合并两个有序的单链表，合并后依然有序

     

## 双向链表

1. 单向链表，查找的方向只能是一个方向（只能通过遍历进行查找），而双向链表可以向前或者向后查找。

2. 单向链表不能自我删除，要依靠辅助节点，而双向链表可以自我删除，所以前面使用单链表删除节点时，我们总是找到被删除节点的前一个节点。

3. 图解：

   ![image-20220321150659298](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220321150659298.png)

分析双向链表的遍历，添加，修改，删除的操作思路

1. 遍历：与单向链表相同，不过因为双向链表多了pre所以它可以向前遍历 ，也可以向后遍历。
2. 添加（默认添加到双向链表的最后）temp指的是最后一个节点。
   1. 先找到双向链表的最后一个节点
   2. temp.next = new Node
   3. new Node.pre = temp.
3. 修改 思路和单向链表相同。
4. 删除
   1. 首先找到需要删除的节点，temp
   2. temp.pre.next = temp.next
   3. temp.next.pre = temp.pre

### 代码实例

```
package LinkedList.DoubleLinkedList;
/**
 * @author 巩泽楷
 * @version 1.0
 */
public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        //双向链表
        System.out.println("双向链表的测试");
        //创建节点
        HeroNode2 h1 = new HeroNode2(1,"A","a");
        HeroNode2 h2 = new HeroNode2(2,"B","b");
        HeroNode2 h3 = new HeroNode2(3,"C","c");
        HeroNode2 h4 = new HeroNode2(4,"D","d");
        //创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(h1);
        doubleLinkedList.add(h2);
        doubleLinkedList.add(h3);
        doubleLinkedList.add(h4);

        System.out.println("按顺序添加");
        doubleLinkedList.addByOrder(h2);
        doubleLinkedList.addByOrder(h1);

        doubleLinkedList.show();

        //修改
        HeroNode2 nh = new HeroNode2(4,"E","e");
        doubleLinkedList.update(nh);
        System.out.println("修改后");
        doubleLinkedList.show();

        //删除
        doubleLinkedList.del(4);
        doubleLinkedList.show();

    }
}


//创建一个双向链表
class DoubleLinkedList{
//    private HeroNode2 head;
//    //Constructor
//    public DoubleLinkedList() {
//        this.head = null;
//    }
     private HeroNode2 head = new HeroNode2(0,"","");

    //显示链表
    public void show(){
        //判断链表是否为空
        if (this.head.next==null){
            System.out.println("链表为空");
            return;
        }
        HeroNode2 temp = head.next;
        while(true){
            //判断链表是否到了最后
            if (temp == null){
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }

    //添加节点
    //添加节点到单向链表
    //思路：当不考虑当前编号顺序时，
    //1.找到当前链表的最后节点。
    //2.将最后这个节点的next指向新的节点。
    public void add(HeroNode2 heroNode2){
        //因为head节点不能动，因此需要一个对象来辅助遍历
        HeroNode2 temp = this.head;
        //遍历链表，找到最后
        while(true){
            if (temp.next == null){
                break;  //退出循环
            }
            temp = temp.next;
        }
        //当退出循环时，temp就指向了链表的最后
        //此时，temp.next应当指向被添加的节点，heroNode.pre指向前一个节点。
        //构成双向链表
        temp.next = heroNode2;
        heroNode2.pre = temp;
    }

    //按顺序加入链表
    public void addByOrder(HeroNode2 heroNode){
        //与上面的方法类似，使用temp来查找添加的位置。
        HeroNode2 temp = head;
        HeroNode2 cur = head.next;
        boolean flag = false;
        while (true){
            if (temp.next == null){
                break;
            }
            if (temp.next.no > heroNode.no){
                break;
            }
            if (temp.no == heroNode.no){
                flag = true;//说明添加的编号已经存在
                break;
            }
            temp = temp.next;
        }
        if (flag){
            System.out.println("编号"+heroNode.no+"已经存在，不能加入");
        } else {
            temp.next.pre = heroNode;
            temp.next =heroNode.next;
            heroNode.pre = temp;
        }
    }


    //修改节点的信息，根据no的编号进行修改
    //基本上与单向链表相同
    public void update(HeroNode2 newHeroNode){
        //判断是否为空
        if (head.next ==null){
            System.out.println("该列表为空。");
            return;
        }
        //根据no的编号，找到需要修改的节点。
        HeroNode2 temp = head.next;
        boolean flag = false;
        while (true){
            if(temp == null){
                break;
            }
            if (temp.no == newHeroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断是否找到
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            System.out.println("没有找到相应的编号。");
        }
    }
//删除节点
//思路：
//1. 首先找到需要删除的节点，temp
//2. temp.pre.next = temp.next
//3. temp.next.pre = temp.pre
    public void del(int no){        //按照编号删除
        HeroNode2 temp = head;   //删除目标的前一个节点
        boolean flag = false;
        //判断
        while (true){
            //判断是否为空
            if (temp == null){
                break;
            }
            if (temp.no == no){
                //找到的待删除节点的前一个temp
                flag = true;
                break;
            }
            temp =temp.next;
        }
        //执行
        if (flag){
            temp.pre.next = temp.next;
            //前提，temp不是最后一个
            if (temp.next !=null){
                temp.next.pre = temp.pre;
            }
        }else {
            System.out.println("要删除的节点不存在。");
        }
    }









}
class HeroNode2{
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next;   //下一个节点
    public HeroNode2 pre;   //前一个节点
    //constructor

    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' ;
    }
}
```

## 环形链表

### 单向环形链表

* 构建：
  1. 创建第一个节点，让first指向该节点，并形成环形。
  2. 后面当我们每创建一个新的节点，就把该节点加入到环形链表中。
* 遍历
  1. 设一个辅助指针curBoy
  2. 然后通过一个while循环遍历该环形链表即可curBoy.next = first结束。

注意环形链表没有head（头节点）

代码实例：

```
package LinkedList.DoubleLinkedList;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class Josepfu {
    public static void main(String[] args) {
        //测试环形链表和遍历
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

    }
}

//创建环形的单向链表
class CircleSingleLinkedList{
    //创建一个first节点
    private Boy first = new Boy(-1);


    //添加小孩的节点，构建成一个环形链表,
    public void addBoy(int nums){
       //校验数据是否符合条件
        if (nums<1){
            System.out.println("nums的值不正确。");
            return;
        }
        Boy curBoy = null;
        //使用for来创建环形链表
        for (int i = 1; i <= nums; i++) {
            Boy boy = new Boy(i);
            if (i==1){
                first = boy;
                first.setNext(first);   //构成一个环。
                curBoy = first; //为了i>1的做准备
            }else {
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;   //让curBoy指向boy以保证下一次的循环。
            }
        }
    }

    //遍历出当前环形链表
    public void showBoy(){
        if (first==null){
            System.out.println("链表为空。");
            return;
        }
        //因为first不能被使用，所以要创建另一个新的指针。
        Boy curBoy = first;
        while (true){
            System.out.println("编号："+curBoy.getNo());
            if (curBoy.getNext() == first){
                break;
            }else {
                curBoy = curBoy.getNext();
            }

        }
    }
}


//创建节点
class Boy{
    private int no;
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }
    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```

### Josephu（约瑟夫）问题 

![image-20220321203327362](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220321203327362.png)

思路：1.需求创建一个辅助指针（变量）helper，事先应该指向环形链表的最后一个节点。

2. 当小孩报数时，让first和helper指针同时移动m-1次。

3. 这时就可以将first指向小孩的节点出圈。因为此时，first指向应当被移除的节点。

   first = first.next

   helper.next = first

4. 原来的first指向节点没有任何引用，会被垃圾回收机制回收。

```
package LinkedList.DoubleLinkedList;

/**
 * @author 巩泽楷
 * @version 1.0
 * Josephu问题的题解和环形链表的基础操作
 */
public class Josepfu {
    public static void main(String[] args) {
        //测试环形链表和遍历
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();

        //测试约瑟夫问题
        circleSingleLinkedList.countBoy(1,2,5);
    }

}

//创建环形的单向链表
class CircleSingleLinkedList{
    //创建一个first节点
    private Boy first = new Boy(-1);


    //添加小孩的节点，构建成一个环形链表,
    public void addBoy(int nums){
       //校验数据是否符合条件
        if (nums<1){
            System.out.println("nums的值不正确。");
            return;
        }
        Boy curBoy = null;
        //使用for来创建环形链表
        for (int i = 1; i <= nums; i++) {
            Boy boy = new Boy(i);
            if (i==1){
                first = boy;
                first.setNext(first);   //构成一个环。
                curBoy = first; //为了i>1的做准备
            }else {
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;   //让curBoy指向boy以保证下一次的循环。
            }
        }
    }

    //遍历出当前环形链表
    public void showBoy(){
        if (first==null){
            System.out.println("链表为空。");
            return;
        }
        //因为first不能被使用，所以要创建另一个新的指针。
        Boy curBoy = first;
        while (true){
            System.out.println("编号："+curBoy.getNo());
            if (curBoy.getNext() == first){
                break;
            }else {
                curBoy = curBoy.getNext();
            }

        }
    }
    //约瑟夫问题
    /*
        startNo:表示从第几个小孩开始数数
        countNum：表示数几下
        nums：表示最初有多少个小孩在圈中。
     */
    public void countBoy(int startNo,int countNum,int nums){
        if (first == null||startNo<1||startNo>nums){
            System.out.println("参数有误，请重新输入。");
            return;
        }
        // 创建辅助指针，完成出圈。
        Boy helper = first;
        //创建一个辅助变量helper，指向该环形链表的最后一个节点
        while (true){
            if (helper.getNext() == first){
                break;
            }
            helper = helper.getNext();
        }
        //在报数前先让first移动到开始报数的位置。同样，helper也移动到相应的位置。
        for (int i = 0; i <startNo-1 ; i++) {
            first = first.getNext();
            helper = helper.getNext();
        }
        //进行报数，将first和helper指针移动m-1次,m是数次数countNum，然后出圈。
        //这是一个循环操作，需要不断的出圈，直到只剩下一个人。
        while (true){
            if (helper == first){
                break;
            }
            //让first和helper指针同时移动countNum-1,找到需要出圈的人
            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                helper = helper.getNext();
            }
            //上面找到了需要出圈的人，接下来出圈。
            System.out.println("出圈的人:"+first.getNo());
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("最后留在圈中的人"+first.getNo());
    }
}


//创建节点
class Boy{
    private int no;
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }
    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
```

## 栈

1. 栈的英文为stack
2. 栈是一个**先入后出**的有序列表。
3. 栈（stack）是限制性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，称为变化的一端，称为**栈顶**，另一端为固定的一段，称为栈底。
4. 根据栈的定义，最先放入栈中的元素在栈底，最后放入的元素在栈顶。而删除元素恰好相反。
5. 出栈（pop）和入栈（push）的概念：

![image-20220322152223671](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220322152223671.png)

### 栈的应用场景

![image-20220322152537264](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220322152537264.png)

### 栈的快速入门

利用数组来对栈进行模拟

1. 使用数组来模拟栈
2. 定义一个top来表示栈顶，初始化为-1。
3. 入栈的操作，当有数据加入到栈时，top++；stack[top] = data。
4. 出栈的操作，int value = stack[top];  top--,return value.

```
package Stack;

import java.util.Scanner;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class ArrayStackdemo {
    public static void main(String[] args) {
        //测试ArrayStack是否正确
        //先创建一个ArrayStack对象 - >表示栈
        ArrayStack arrayStack = new ArrayStack(4);
        String key = "";
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);
        while (loop){
            System.out.println("show:显示栈。");
            System.out.println("exit:退出程序。");
            System.out.println("push:添加数据。");
            System.out.println("pop:删除数据。");
            key = scanner.next();
            switch (key){
                case "show":
                    arrayStack.list();
                    break;
                case "push":
                    System.out.println("请输入添加数：");
                    int value = scanner.nextInt();
                    arrayStack.push(value);
                    break;
                case  "pop":
                    try {
                        int res = arrayStack.pop();
                        System.out.println(res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    System.out.println("栈已退出");
                    break;
            }

        }
    }
}

//定义一个ArrayStack表示栈
class ArrayStack{
    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }


    //判断栈是否满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //判断栈是否为空
    public boolean isEmpty(){
        return top==-1;
    }
    //入栈 push
    public void push(int value){
        //先判断栈是否满
        if (isFull()==true){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈 pop
    public int pop(){
        if (isEmpty()==true){
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况
    public void list(){
        if (isEmpty()){
            System.out.println("栈为空");
            return;
        }
        //从栈顶开始显示数据
        for (int i = top; i >=0; i--) {
            System.out.println(stack[i]);
        }
    }

}
```

### 使用栈计算一个数学表达式的结果

思路：

1. 通过一个index值作为索引，来遍历整个表达式。建立两个栈分别用来存放数字和符号。
2. 如果发现一个字符是数字，就直接入数栈。
3. 1. 如果一个字符串是符号，且当前的符号栈为空，就直接入栈。
   2. 如果一个字符串是符号，且当前的符号栈不为空，就进行比较，<font size =3 color = "red">**如果当前的操作符的优先级小于或者等于栈中的操作符**，</font>就需要从数栈中pop两个数字，从符号栈中pop出一个符号。进行运算，然后将得到的结果加入数栈，然后将当前的操作符号加入符号栈。<font size =3 color = "red">**如果当前的操作符的优先级大于栈中的操作符，**</font>就直接将符号入栈。
4. 当前表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行计算。
5. 当数栈中仅存在一个数字时，运算完毕。

```
package Stack;

/**
 * @author 巩泽楷
 * @version 1.0
 * 用栈完成某个数学表达式的计算结果
 */
public class Calculator {
    public static void main(String[] args) {
//        1. 通过一个index值作为索引，来遍历整个表达式。建立两个栈分别用来存放数字和符号。
//        2. 如果发现一个字符是数字，就直接入数栈。
//        3. 1. 如果一个字符串是符号，且当前的符号栈为空，就直接入栈。
//           2. 如果一个字符串是符号，且当前的符号栈不为空，就进行比较，
//           <font size =3 color = "red">**如果当前的操作符的优先级小于或者等于栈中的操作符**，
//           </font>就需要从数栈中pop两个数字，从符号栈中pop出一个符号。进行运算，
//           然后将得到的结果加入数栈，然后将当前的操作符号加入符号栈。<font size =3 color = "red">**
//           如果当前的操作符的优先级大于栈中的操作符，**</font>就直接将符号入栈。
//        4. 当前表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行计算。
//        5. 当数栈中仅存在一个数字时，运算完毕

        //根据前面老师的思路，完成表达式的运算
        String  expression = "300+2*6-2";
        //创建两个栈，一个数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量。
        int index = 0;  //遍历索引标识
        int num1 =0;    //表示数字1的位置
        int num2 =0;    //表示数字2的位置
        int oper =0;    //符号位置
        int res = 0;    //结果
        char ch = ' ';  //每次扫描的结果保存于此
        String keepNum = "";   //用于多位数之间的连接。
        //循环扫描expression
        while (true){
            //依次得到expression的每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            //判断第一个字符是否是符号，然后做相应的处理。
            if (operStack.isOper(ch)){
                //如果是，判断当前符号栈是否为空。
                if (operStack.isEmpty()==false){
                    //如果符号栈不为空，则进行比较
                    if (operStack.priority(ch)<= operStack.priority(operStack.peek())){
                        //如果进行比较的符号的优先级小于或等于在栈中的符号的优先级,则进行运算。
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        //运算结束，将res插入数栈，ch插入符号栈
                        numStack.push(res);
                        operStack.push(ch);
                    }else {
                        //如果进行比较的符号的优先级大于在栈中的符号的优先级,则压入符号栈。
                        operStack.push(ch);
                    }
                }else {
                    //在符号栈为空的情况下
                    operStack.push(ch);
                }
            }else {
                //如果是数，则直接如数栈
                //numStack.push(ch-48);
                //修改，当数字是多位数时，不成立
                //思路分析：
                //1. 当处理多位数时，不能发现一个数就立刻入栈，因为可能是多位数。
                //2. 所以，我们应当再读取数字后面的数，直到是符号为止。（这里不考虑小数）
                //3. 因此，我们需要一个字符串来保存我们读到的数据

                //处理多位数
                keepNum += ch;  //keepNum=keepNum+char
                //判断ch是不是最后一位数字
                if (index==expression.length()-1){
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    //判断下一个字符是不是操作符，注意是下一个。
                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) { 
                        //如果是运算符，则入栈
                        numStack.push(Integer.parseInt(keepNum));
                        //将keepnum清空，保证下一次运算正确
                        keepNum = "";
                    }
                }

            }
            //让index+1，是循环成立。并判断是否扫描到expression的最后。
            index++;
            if (index>=expression.length()){
                break;
            }
        }
        //通过上述代码，将表达式扫描完毕。顺序从数栈和符号栈中取出相应的数和符号，并运行。
        while (true){
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            numStack.push(res);
        }
        System.out.println(expression+":"+numStack.pop());
    }
}
//定义一个ArrayStack2表示栈
class ArrayStack2{
    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }


    //判断栈是否满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //判断栈是否为空
    public boolean isEmpty(){
        return top==-1;
    }
    //入栈 push
    public void push(int value){
        //先判断栈是否满
        if (isFull()==true){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈 pop
    public int pop(){
        if (isEmpty()==true){
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //返回当前栈顶的值，但并不取出。
    public int peek(){
        return stack[top];
    }
    //显示栈的情况
    public void list(){
        if (isEmpty()){
            System.out.println("栈为空");
            return;
        }
        //从栈顶开始显示数据
        for (int i = top; i >=0; i--) {
            System.out.println(stack[i]);
        }
    }

    //判断运算符号的优先级，用数字表示，数字越大，优先级越高。
    public int priority(int oper){
        if (oper == '*'|| oper=='/'){
            return 1;
        }else if (oper == '+'||oper=='-'){
            return 0;
        }else {
            return -1;  // 假定目前的表达式只有加减乘除
        }
    }
    //判断是不是运算符
    public boolean isOper(char val){
        return val == '+'|| val == '-' || val == '*' || val == '/';
    }
    //计算方法
    public int cal(int num1, int num2, int oper){
        int res = 0;    //计算的结果
        switch (oper){
            case '+':
                res = num1+num2;
                break;
            case '-':
                res = num2-num1;
                break;
            case '*':
                res = num2*num1;
                break;
            case '/':
                res = num2/num1;
            default:
                break;
        }
            return res;
    }
}
```

## 前缀，中缀，后缀表达式

### 前缀表达式

1. 前缀表达式又称**波兰式**，前缀表达式的运算符位于操作数之前。
2. 举例：（3+4）*5-6对应的前缀表达式就是- * + 3 4 5  6

**计算机求值**

从右到左扫描表达式，遇到数字时，将数字压入栈堆，遇到运算符时，弹出栈顶的两个数，用运算符对于它们进行相应的运算，然后将结果入栈。重复上述过程直到到达表达式的最左端，最后运算得出的值即为表达式的结果。

![image-20220323182023359](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220323182023359.png)

### 中缀表达式

![image-20220323181025079](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220323181025079.png)

 **计算机求值如上文代码**

## 后缀表达式

1. 后缀表达式又称为逆波兰表达式与前缀表达式相似，只是运算符位于操作数之后。
2. 举例：（3+4）*5-6 ----> 3 4 +5 * 6 -
3. ![image-20220323181306114](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220323181306114.png)

* 明显，不需要判断优先级。

**计算机求值**

从左到右扫码表达式，在遇到数字的时候，将数字压入栈堆，遇到运算符时，弹出栈顶的两个数，用运算符对其做相应的运算。并将结果入栈。重复上述操作直到表达式的最右端，最后得出的值即为表达式的结果。

![image-20220323182101316](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220323182101316.png)

 ### 逆波兰计算器

思路于后缀表达式中的计算机求值思路相同

```
package Stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * @author 巩泽楷
 * @version 1.0
 * 逆波兰计算器
 */
public class PolandNotation {
    public static void main(String[] args) {
        //定义逆波兰表达式
        //(3+4)*5-6 => 3 4 + 5 * 6 -
        String suffixExpression = "30 4 + 5 * 6 -";
        String suffixExpression1 = "4 5 * 8 - 60 + 8 2 / +";
        //思路
        //1. 先将"3 4 + 5 * 6 -"放到ArrayList中。
        List<String> list = getListString(suffixExpression1);
        int res = calculate(list);
        System.out.println(res);
    }
    //将一个逆波兰表达式，依次将数据和运算符放到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //首先将suffixExpression中的字符提取出来。
        String[] spilt = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for (String ele :spilt) {
            list.add(ele);
        }
        return list;
    }
    //完成逆波兰表达式的计算。
    public static int calculate(List<String> ls){
        //创建栈
        Stack<String> stack = new Stack<>();
        //遍历 ls
        for (String item :ls) {
            if (item.matches("\\d+")){  //matches的作用是判断字符串中是否存在某字符串。
                //如果是数字
                ////判断是否包含字母，改为 .*[a-zA-Z]+.*  是否包含汉字改为 .*[\u4e00-\u9fa5].*这是正则表达式
                stack.push(item);
            }else { //如果是字符
                //pop出两个数，并运算，再入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1+num2;
                }else if (item.equals("-")){
                    res = num2-num1;
                }else if (item.equals("*")){
                    res = num1*num2;
                }else if (item.equals("/")){
                    res = num2/num1;
                }else {
                    throw new RuntimeException("运算符有误。");
                }
                //把res 入栈
                stack.push(""+res); //一个将
            }

        }
        //最后返回运算结果。
        return Integer.parseInt(stack.pop());
    }
}
```

### 如何将中缀表达式转换位后缀表达式

**具体步骤**：

1. 初始化两个栈：运算符栈s1和储存中间结果的s2；
2. 从左到右扫描中值表达式
3. 遇到操作数时，将其压如s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级；
   1. 如果s1为空，或者栈顶运算符为左括号“(”,则直接将运算符压入栈；
   2. 否则，若优先级比栈顶运算符的高，也将压入s1；
   3. 否则，若优先级比栈顶运算符的低或者等于，则将s1栈顶的运算符号弹出并压入到s2中，之后再次转到 （4.a）与s1中新的栈顶运算符相比较。
      * <font size=3 color="blue">*上面abc其实就是两种情况，当s1不为空，且新的运算符优先级比栈顶运算符的低或者等于时，将s1栈顶的运算符号弹出并压入到s2中。 否则，直接压入s1*.</font>
5. 遇到括号时：
   1. 如果是左括号“(”, 则直接压入s1
   2. 如果是右括号“)”, 则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃。
6. 重复步骤2-5，直到到达表达式的最右边。
7. 将s1中剩余的运算符依次弹出并压入s2.
8. 依次弹出s2中的元素并输出，结果的**逆序表达式**即为目标表达式。
   * 注意，**小括号不是运算符**。

**实际例子**：

![image-20220324112901903](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220324112901903.png)

**代码示例：**

* 下面是一个完整的中缀和后缀表达式的计算器，其中和逆波兰计算机有重复，是在其上修改得到的。（不包含小数）

```
/**
 * @author 巩泽楷
 * @version 1.0
 * 逆波兰计算器
 */
public class PolandNotation {
    public static void main(String[] args) {
        //定义逆波兰表达式
        //(3+4)*5-6 => 3 4 + 5 * 6 -
        String suffixExpression = "30 4 + 5 * 6 -";
        String suffixExpression1 = "45 * 8 - 60 + 8 2 / +";
        String expression = "1+((2+3)*4)-5";
//        List<String> list1 = toInfixExpressionList(infixExpression);
//        System.out.println(list1);
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式对应的list："+infixExpressionList);
        List<String> suffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("用中缀表达式转换为的后缀表达式："+suffixExpressionList);

        //思路
        //1. 先将"3 4 + 5 * 6 -"放到ArrayList中。
//        List<String> list = getListString(suffixExpression1);
//        int res = calculate(list);
//        System.out.println(res);
    }
    //将一个逆波兰表达式，依次将数据和运算符放到ArrayList中
    public static List<String> getListString(String suffixExpression){
        //首先将suffixExpression中的字符提取出来。
        String[] spilt = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for (String ele :spilt) {
            list.add(ele);
        }
        return list;
    }

    //将中缀表达式转换成相对应的List数组
    // s = "1+((2+3)*4)-5"
    public static List<String> toInfixExpressionList(String s){
        //首先定义一个List，存放其对应的中值表达式的内容。
        //目的在于将中缀表达式转为String格式。
        List<String> ls = new ArrayList<>();
        int i = 0;  //一个指针，用于遍历中缀表达式的字符串。
        String str; //对多位数的拼接
        char c;     //每遍历一个字符，就放入到c中。
        do{
            //如果c就是一个非数字，则我们需要加入ls
            if ((c = s.charAt(i))<48 || (c = s.charAt(i))>57){  //根据ASCII表格得出的int与char之间的关系转换。
                //数字在ASCII的编码中，>=48，<=57
                ls.add(""+c);
                i++;
            }else { //如果c是一个数字，则我们需要考虑多位数
                str = "";   //先将str置零，防止影响下一次循环，
                while (i<s.length()&&(c=s.charAt(i))>=48&&(c=s.charAt(i))<=57){
                    str += c;   //str = str+c
                    i++;
                }
                ls.add(str);
            }
        }while (i<s.length());
        return ls;

    }


    //将中缀表达式对应的List转换成后缀表达式的list
    public static List<String> parseSuffixExpressionList(List<String> list){
        Stack<String> s1 = new Stack<String>();
        //按照笔记的思路分析，我们需要两个栈，但是第二个栈s2只是用来存储数据并在最后时候
        //将其逆序输出，中途并没有用到pop方法。
        //所以我们可以用List来代替s2进行存储。
        //Stack<String> s2 = new Stack<String>();
        List<String> s2 = new ArrayList<>();    //代替s2存储数据
        //遍历数组
        for (String item :list) {
            //遇到操作数
            if (item.matches("\\d+")){  //正则表达式
                s2.add(item);
            //遇到括号
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                while (!s1.peek().equals("(")) { //peek会拿出出栈顶的值，但栈中仍存在这个值。
                    s2.add(s1.pop());
                }
                s1.pop();   //目的是清除之前压进去的小括号。
            }else {
                //当遇到运算符
                //利用operation来进行优先级的比较
                while (s1.size()!=0 && Operation.getValue(s1.peek())>= Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                    s1.push(item);
            }
        }
        //将数据处理完毕，将s1中剩余的数依次压入s2
        while (s1.size()!=0){
            s2.add(s1.pop());
        }
        return s2;
    }


    //完成逆波兰表达式的计算。
    public static int calculate(List<String> ls){
        //创建栈
        Stack<String> stack = new Stack<>();
        //遍历 ls
        for (String item :ls) {
            if (item.matches("\\d+")){  //matches的作用是判断字符串中是否存在某字符串。
                //如果是数字
                ////判断是否包含字母，改为 .*[a-zA-Z]+.*  是否包含汉字改为 .*[\u4e00-\u9fa5].
                // *这是正则表达式
                stack.push(item);
            }else { //如果是字符
                //pop出两个数，并运算，再入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")){
                    res = num1+num2;
                }else if (item.equals("-")){
                    res = num2-num1;
                }else if (item.equals("*")){
                    res = num1*num2;
                }else if (item.equals("/")){
                    res = num2/num1;
                }else {
                    throw new RuntimeException("运算符有误。");
                }
                //把res 入栈
                stack.push(""+res); //一个将
            }

        }
        //最后返回运算结果。
        return Integer.parseInt(stack.pop());
    }
}
//增加一个类，来判断运算符的优先级
class Operation{
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个可以判断优先级的方法
    public static int getValue(String operation){
        int result = 0;
        switch (operation){
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("请输入正确格式的字符。");
                break;
        }
        return result;
    }
}
```

## 递归

递归就是方法自己调用自己，每次调用时传入不同的变量，递归有利于编程者解决复杂的问题，同时可以让代码变得简洁。

#### 实例解析

1.打印问题

![image-20220325142152423](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325142152423.png)

2.阶乘问题

![image-20220325142605095](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325142605095.png)

### 递归可以解决的问题

![image-20220325144901949](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325144901949.png)

* 其实递归可以解决的往往是具有**重复性**的问题。

### 使用递归的重要规则：

1. 执行一个方法时，就创建一个新的受保护的空间。（栈空间）
2. 方法的局部变量是独立的，不会相互影响。
3. 但是也有可能存在多个独立的栈的数据引用指向同一个数据空间。比如方法中使用的是引用类型变量（比如数组），就会共享该引用类型数据。
4. 递归必须向退出递归的条件逼近，否则将无限递归，形成死循环。
5. 当一个方法执行完毕时，或者在遇到return时，就会返回，遵守谁调用，就将结果返回给谁。同时当方法执行完毕返回时，该方法也就执行完毕。

###  迷宫回溯问题

 ![image-20220325165927028](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325165927028.png)

**代码解析：**

```
package Recursion;

/**
 * @author 巩泽楷
 * @version 1.0
 * 利用递归解决迷宫回溯问题。
 */
public class Maze {
    public static void main(String[] args) {
        //第一步：创建迷宫
        //1.利用二维数组模拟迷宫
        int[][] map = new int[8][7];//一个8*7的迷宫
        int row_map = map.length;//8
        int col_map = map[0].length;//7
        //2.模拟迷宫的墙壁，将所有的墙壁用1表示。
        //按照图示将合适的位置放上墙壁。
        //上下
        for (int i = 0; i < col_map; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        //左右
        for (int i = 0; i < row_map; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置挡板的墙
        map[3][1]=1;
        map[3][2]=1;
//        map[1][2]=1; 将地图修改为此，会发生回溯
//        map[2][2]=1;
        //输出地图
        System.out.println("地图的情况：");
        for (int i = 0; i < row_map; i++) {
            for (int j = 0; j < col_map; j++) {
                System.out.print(map[i][j]+"\t");
            }
            System.out.println();
        }

        findWay(map,1,1);
        System.out.println("地图的情况：");
        for (int i = 0; i < row_map; i++) {
            for (int j = 0; j < col_map; j++) {
                System.out.print(map[i][j]+"\t");
            }
            System.out.println();
        }
    }

    //3.使用递归回溯来寻找合适的路线
    //(1)map表示地图，i，j表示开始的位置map[i][j]，这里认为是(1,1)
    //(2)当小球到达预定地点map[x][y]则说明到达终点，通路找到。这里设定为(6,5)
    //(3)为了寻找合适的路线，我们如下设计，0，没有走过；1，表示墙，无法通过；2，表示通路可以走；3，表示该点已经走过，但是走不通。
    //(4)制定一个测略，来明确寻找的先后顺序。下->右->上->左。如果走不通，再回溯。

    public static boolean findWay(int[][] map, int i, int j){
        if(map[6][5] == 2){
            return true;
        }else {
            if (map[i][j] == 0){//假设这个点现在还没有走过，为0
                //按照设计的策略：下->右->上->左
                map[i][j] =2;
                if (findWay(map,i+1,j)){//向下走
                    return true;
                }else if (findWay(map,i,j+1)){//向右走
                    return true;
                }else if (findWay(map,i-1,j)){//向上走
                    return true;
                }else if (findWay(map,i,j-1)){
                    return true;
                }else {
                    //说明该点走不通，死路。
                    map[i][j] = 3;
                    return false;
                }
            }else {//此时，这个位置可能等于1，2，3.
                return false;
            }

        }



    }
}
```

### 八皇后问题

![image-20220325171043643](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325171043643.png)

### 思路分析：

1. 将第一个皇后放到第一行第一列
2. 将第二格皇后放到第二行第一列，判断是否可行，如果不，则放到第二行第三列，依次类推，直到满足条件
3. 继续放第三个皇后，同步骤2，在第三行中寻找可行的列。后面同理，直到第8个皇后也放到了一个互不冲突的位置，找到了一个最优解。
4. 当得到一个正确的解的时候，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放到第一列的所有正确的解全部得到。
5. 然后回头继续第一个皇后放到第二列，继续执行1，2，3，4的步骤。

* 理论上我们可以通过一个二维数组来表示棋盘，但实际上一个一维数组就可以解决所有问题。
* ![image-20220325172403218](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220325172403218.png)

```
package Recursion;

/**
 * @author 巩泽楷
 * @version 1.0 
 */
public class Queue8 {
    int max = 8;
    //定义数组array，保存皇后放置的位置，比如 arr = {0，4，7，5，2，6，1，3}
    int[] array = new int[max];
    static int count = 0;
    public static void main(String[] args) {
        //测试八个皇后的代码是否完善。
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.println("一共有"+ count);


    }
    //编写一个方法，放置第n个皇后
    public void check(int n){
        if (n == max){
            print();    //此时，n=8，实际上已经轮到了不存在的第九个皇后，所有直接放就行。
            //只有满足条件才会打印，所有打印多少次就代表有多少个解法。
            System.out.println();
            //System.out.println();
            return;
        }
        for (int i = 0; i < max; i++) {
            //先把当前这个皇后n,放到该行的第1列
            array[n] = i;
            if (judge(n)){
                //利用递归，如果判断存在有皇后不影响当前皇后的位置，则放下一个皇后。
                check(n+1);
            }
            //如果影响，则再次for循环寻找下一个位置。
        }
    }
    //在放置了n个皇后之后，判断皇后之间位置是否冲突
    //n表示第n+1个皇后
    public boolean judge(int n){
        for (int i = 0; i <n ; i++) {
            //说明：
            //1.array[i] = array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一侧。
            //2.Math.abs(n-i)==Math.abs(array[n]-array[i]),利用三角形的两边长来解决两个皇后是否在同一斜线。
            //3.没有必要判断是否在同一行。因为n本身就有行的意思。
            if (array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i])){
                return false;   //若影响，则返回false
            }
        }
        return true;    //若不影响，则返回true
    }
    //将皇后的位置输出
    public void print(){
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]+" ");
        }
    }
}
```

## 排序（Sort Algorithm）

: 排序是将一组数据，按照指定的顺序进行排序的过程。

### 排序的分类

1. 内部排序：指将需要的处理的所有数据都加载到内部存储器中进行排序。
2. 外部排序：当数据量过大，无法全部加载到内存中时，需要借助外部存储进行排序。
3. 常见的排序算法分类：![image-20220327154746019](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327154746019.png)

## 算法的时间复杂度

方法：

1.  事后统计的方法：存在问题，1)想要对设计的算法的运行性能进行评测，需要实际运行该程序。2)所得的时间的统计量依赖于计算机的硬件，软件等环境因素，这种方法要在**同一台计算机的相同状态下运行**，才能比较哪一个算法的速度更快。
2. 事前估计的方法：通过分析某个算法的时间复杂度来判断哪个算法更优。

### 时间频度

基本介绍：一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句的执行次数多，它花费的时间就更多。**一个算法中语句执行次数称为语句频度或时间频度，记为T(n).**

* 统计时间频度时，可以忽略常数项。
* 统计时间频度时，可以忽略系数。

## 时间复杂度

1. 一般情况下，**算法中的基本操作语句的重复执行次数是问题规模n的某个函数，一般用T(n)来表示**，若有某个辅助函数f(n)，使得当n趋于无穷大时，T(n)/f(n)的极限值为不等于0的常数，则称f(n)是T(n)的同数量级函数。**记作T(n) = O(f(n)), O(f(n))为算法的渐进时间复杂度，简称为时间复杂度**。

   1.  T(n)=n+1; f(n) = n; T(n) = O(n)

2. T(n)不同，但是时间复杂度可能相同。

   ![image-20220327162256666](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327162256666.png)

3. 计算时间复杂度的方法：
   1. 用常数1代替运行时间中所有的加法常数
   2. 修改后的运行次数函数中，只保留最高阶项。
   3. 去除最高阶项的系数。

![image-20220327162607608](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327162607608.png) 

### 常见的时间复杂度

![image-20220327162921392](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327162921392.png)

* O(n!)最大



1.常数阶

无论代码执行了多少行，只要是没有循环的复杂结构，，那么这个代码的时间复杂度都是常数阶复杂度。

2.对数阶

![image-20220327163445082](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327163445082.png)

3.线性阶

![image-20220327163516650](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327163516650.png)

4.线性对数阶

![image-20220327163533405](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327163533405.png)

5.平方阶

 ![image-20220327163642109](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327163642109.png)

其余的是上述几种时间复杂度的组合。

**？那么指数阶怎么办？**

### 平均时间复杂度和最坏时间复杂度

1. 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. 最坏情况下的时间复杂度称为最坏时间复杂度。**一般讨论的时间复杂度均是在最坏条件下的时间复杂度**。原因是可以保证算法时间不会比最坏的情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致和算法有关。

![image-20220327165048140](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327165048140.png)

## 空间复杂度

![image-20220327165356478](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220327165356478.png)

 

## 冒泡排序(BubbleSort)

基本思想：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻的值，若发现逆序则交换，使值**比较大**的元素逐渐**从前向后移**。

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行交换，说明序列有序，因此要在排序过程中设置一个标志的flag判断元素是否进行过交换。从而减少不必要的比较。

```
package Sort;


import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 * 冒泡排序
 */
public class BubbleSort {
    public static void main(String[] args) {
        int array[] = {3,9,-1,10,-2};
        //冒泡排序
        //第一轮排序，找出最大的
        int temp = 0;
        for (int i = 0; i < array.length-1; i++) {
            if (array[i]>array[i+1]){
                //交换位置
                temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
        System.out.println("放在第一趟最后的数组。");
        System.out.println(Arrays.toString(array));

        //第二趟排序找出第二大的
        for (int i = 0; i < array.length-1-1; i++) {//减1的目的是不用计算最大的数
            if (array[i]>array[i+1]){
                //交换位置
                temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
        System.out.println("放在第二趟最后的数组。");
        System.out.println(Arrays.toString(array));

        //后面以此类推

        //最后总结
        for (int i = 0; i < array.length-1; i++) {
            for (int j = 0; j < array.length-i-1; j++) {
                if (array[j]>array[j+1]){
                    //交换位置
                    temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
            System.out.println(Arrays.toString(array));
        }
    }
}
```

通过时间差来认识到冒泡排序的时间复杂度

```
public class BubbleSort {
    public static void main(String[] args) {
//        int array[] = {3,9,-1,10,-2};
//        System.out.println("排序前：");
//        System.out.println(Arrays.toString(array));
//        bubbleSort(array);
//        System.out.println("排序后：");
//        System.out.println(Arrays.toString(array));

        //测试冒泡排序的速度：时间复杂度O(n*n)
        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random()*80000);
        }

        Date date1 = new Date();    //时间类
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是："+date1Str);
        //System.out.println(Arrays.toString(arr));

        bubbleSort(arr);
        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是："+date2Str);
        //冒泡排序
        //第一轮排序，找出最大的
 /*       for (int i = 0; i < array.length-1; i++) {
            if (array[i]>array[i+1]){
                //交换位置
                temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
        System.out.println("放在第一趟最后的数组。");
        System.out.println(Arrays.toString(array));

        //第二趟排序找出第二大的
        for (int i = 0; i < array.length-1-1; i++) {//减1的目的是不用计算最大的数
            if (array[i]>array[i+1]){
                //交换位置
                temp = array[i];
                array[i] = array[i+1];
                array[i+1] = temp;
            }
        }
        System.out.println("放在第二趟最后的数组。");
        System.out.println(Arrays.toString(array));

        //后面以此类推*/

        //最后总结
//        boolean flag = false;
//        for (int i = 0; i < array.length-1; i++) {
//
//            for (int j = 0; j < array.length-i-1; j++) {
//                if (array[j]>array[j+1]){
//                    //交换位置
//                    flag = true;
//                    temp = array[j];
//                    array[j] = array[j+1];
//                    array[j+1] = temp;
//                }
//            }
//            System.out.println(Arrays.toString(array));
//            if (flag!=true){//算法优化，使得如果提取排序成功，则不进行后面的运算。
//                break;
//            }else {
//                flag = false;
//            }
//        }

    }


    public static void bubbleSort(int[] array){
        int temp = 0;
        boolean flag = false;
        for (int i = 0; i < array.length-1; i++) {

            for (int j = 0; j < array.length-i-1; j++) {
                if (array[j]>array[j+1]){
                    //交换位置
                    flag = true;
                    temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
            //System.out.println(Arrays.toString(array));
            if (flag!=true){//算法优化，使得如果提取排序成功，则不进行后面的运算。
                break;
            }else {
                flag = false;
            }
        }
    }
}
```

## 选择排序算法(SelectSort)

### 基本思想：

![image-20220329162052038](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220329162052038.png)

**例子**：

![image-20220329162227073](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220329162227073.png)

代码实例

```
package Sort;

import java.lang.reflect.Array;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class SelectSort {
    public static void main(String[] args) {
        //int[] arr = {101,34,119,1};
        //System.out.println(Arrays.toString(arr));
        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random()*80000);
        }
        Date date1 = new Date();    //时间类
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是："+date1Str);

        selectSort(arr);

        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是："+date2Str);
    }

    public static void selectSort(int[] arr){
        //总结规律后
        for (int i = 0; i <arr.length-1; i++) {//最后一个值没必要比
            int minIndex = i;
            int min =arr[i];
            for (int j = 0+i; j < arr.length ; j++) {
                if (min>arr[j]){//如果第一个不是最小值，那么进行重置最小值
                    min = arr[j];
                    minIndex= j;
                }
            }
            arr[minIndex] = arr[i];//让寻找到的位置等于0号位置
            arr[i] = min;//让0号位置
           // System.out.println("第"+(i+1)+"轮的结果：");
           // System.out.println(Arrays.toString(arr));
        }
/*        //使用逐步推导的方法来讲解选择排序
        //原始数组：101，34，119，1

        int minIndex = 0;//假设最小值的索引值为0
        int min = arr[0];
        //第一轮：
        for (int i = 0+1; i < arr.length; i++) {//假设0号为最小值，从1号开始比较
            if (min>arr[i]){//如果第一个不是最小值，那么进行重置最小值
                min = arr[i];
                minIndex= i;
            }
        }
        //将最小值交换
        arr[minIndex] = arr[0];//让寻找到的位置等于0号位置
        arr[0] = min;//让0号位置
        System.out.println("第一轮的结果：");
        System.out.println(Arrays.toString(arr));

        //第二轮：寻找第二大的最小值
         minIndex = 1;//假设最小值的索引值为0
         min = arr[1];
        for (int i = 0+1+1; i < arr.length; i++) {//假设0号为最小值，从1号开始比较
            if (min>arr[i]){//如果第一个不是最小值，那么进行重置最小值
                min = arr[i];
                minIndex= i;
            }
        }
        //将最小值交换
        arr[minIndex] = arr[1];//让寻找到的位置等于0号位置
        arr[1] = min;//让0号位置
        System.out.println("第二轮的结果：");
        System.out.println(Arrays.toString(arr));*/

        //第三轮类似，以此类推
    }
}
```

通过对比运行时间可知，同样使O(n*n)冒泡排序要比选择排序用时更长。

## 插入排序(InsertSort)

基本思想：把n个待排序的元素看成为一个有序表和一个无序表，**开始的时候有序表中只包含一个元素，无序表中包含n-1个元素**，在排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之形成新的链表。

![image-20220330161916380](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220330161916380.png)

包括测试时间的代码实列

```
package Sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

/**
 * @author 巩泽楷
 * @version 1.0
 * 插入排序
 */
public class InsertSort {
    public static void main(String[] args) {
        //int[] arr = {101,34,119,1,-1,89};
        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random()*80000);
        }
        //System.out.println(Arrays.toString(arr));
        Date date1 = new Date();    //时间类
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是："+date1Str);

        insertSort(arr);

        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是："+date2Str);
    }
    //插入排序
    public static void insertSort(int[] arr){
        //使用逐渐推导的方式来讲解，便于理解
        //举例数组：{101,34,119,1}-->{34,101,119,1}
        for (int i = 1; i < arr.length; i++) {
            int insertVal = arr[i];
            int insertIndex = i-1;//arr[1]的前面这个数的下标

            //给insetVal 找到插入的位置。
            //说明：
            //1. insertIndex >= 0 保证在给insetVal 找到正确的位置，不越界
            //2. insertVal < arr[insertIndex] 待插入的数
            while (insertIndex>=0&&insertVal < arr[insertIndex]){
                arr[insertIndex+1] = arr[insertIndex];
                insertIndex--;
            }
            if (insertIndex+1==i){
                arr[insertIndex+1] = insertVal;
            }
            //上面的式子有两种情况，
            //1.当while的条件满足时，insertIndex被减了1，所以这里加1来正确交换位置。
            //2.如果否，则说明insetVal大于arr[insertIndex],将数字后移一位，
            // 保证排序正确。
           // System.out.println("第"+(i+1)+"轮输入：");
            // System.out.println(Arrays.toString(arr));

        }


        /*//定义待插入
        int insertVal = arr[1];
        int insertIndex = 1-1;//arr[1]的前面这个数的下标

        //给insetVal 找到插入的位置。
        //说明：
        //1. insertIndex >= 0 保证在给insetVal 找到正确的位置，不越界
        //2. insertVal < arr[insertIndex] 待插入的数
        while (insertIndex>=0&&insertVal < arr[insertIndex]){
            arr[insertIndex+1] = arr[insertIndex];
            insertIndex--;
        }
        arr[insertIndex+1] = insertVal;
        //上面的式子有两种情况，
        //1.当while的条件满足时，insertIndex被减了1，所以这里加1来正确交换位置。
        //2.如果否，则说明insetVal大于arr[insertIndex],将数字后移一位，
        // 保证排序正确。
        System.out.println("第一轮输入：");
        System.out.println(Arrays.toString(arr));

        //第二轮
        insertVal = arr[2];
        insertIndex = 2-1;
        while (insertIndex>=0&&insertVal < arr[insertIndex]){
            arr[insertIndex+1] = arr[insertIndex];
            insertIndex--;
        }
        arr[insertIndex+1] = insertVal;
        //上面的式子有两种情况，
        //1.当while的条件满足时，insertIndex被减了1，所以这里加1来正确交换位置。
        //2.如果否，则说明insetVal大于arr[insertIndex],将数字后移一位，
        // 保证排序正确。
        System.out.println("第二轮输入：");
        System.out.println(Arrays.toString(arr));

        //第三轮
        insertVal = arr[3];
        insertIndex = 3-1;
        while (insertIndex>=0&&insertVal < arr[insertIndex]){
            arr[insertIndex+1] = arr[insertIndex];
            insertIndex--;
        }
        arr[insertIndex+1] = insertVal;
        //上面的式子有两种情况，
        //1.当while的条件满足时，insertIndex被减了1，所以这里加1来正确交换位置。
        //2.如果否，则说明insetVal大于arr[insertIndex],将数字后移一位，
        // 保证排序正确。
        System.out.println("第三轮输入：");
        System.out.println(Arrays.toString(arr));*/
    }
}
```

## 希尔排序(ShellSort)

介绍：首先确定他是一种**插入排序**，是在原有插入排序得基础上改进得到的更优化版本。也被称为“**缩小增量排序**”

基本思想：

希尔排序是把记录按照下标的一定增量分组，对每组使用直接使用插入排序算法排序;随着增量的减少，每组包含的关键词越来越多，当增量减至1时，整个文件都被分成一组，算法中止。

![image-20220331095813878](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220331095813878.png)

![image-20220331102209418](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220331102209418.png)

代码实例：

1. 交换法

   ```
   package Sort;
   
   import java.util.Arrays;
   
   /**
    * @author 巩泽楷
    * @version 1.0
    */
   public class ShellSort {
       public static void main(String[] args) {
           int[] arr = {8,9,1,7,2,3,5,4,6,0};
           shellSort(arr);
       }
       //通过逐步推导完成希尔排序
       //第一轮
       public static void shellSort(int[] arr){
   
           int temp = 0;
           int count = 0;
           for (int gap = arr.length/2; gap >0 ; gap=gap/2) {
               for (int i = gap; i <arr.length ; i++) {
                   for (int j =i-gap; j >=0; j-=gap) {//前五个数因为前面没有数字，所以不进行交换。
                       if (arr[j]>arr[j+gap]){
                           //交换
                           temp = arr[j];
                           arr[j] = arr[j+gap];
                           arr[j+gap] = temp;
                       }
                   }
               }
               count++;
               System.out.println("希尔排序第"+count+"轮："+ Arrays.toString(arr));
   
           }
           /*int temp = 0;
           //希尔排序的第一轮排序
           for (int i = 5; i <arr.length ; i++) {
               for (int j =i-5; j >=0; j-=5) {//前五个数因为前面没有数字，所以不进行交换。
                   if (arr[j]>arr[j+5]){
                       //交换
                       temp = arr[j];
                       arr[j] = arr[j+5];
                       arr[j+5] = temp;
                   }
               }
           }
           System.out.println("希尔排序第一轮："+ Arrays.toString(arr));
   
           //第二轮
            temp = 0;
           //希尔排序的第一轮排序
           for (int i = 2; i <arr.length ; i++) {
               for (int j =i-2; j >=0; j-=2) {//前五个数因为前面没有数字，所以不进行交换。
                   if (arr[j]>arr[j+2]){
                       //交换
                       temp = arr[j];
                       arr[j] = arr[j+2];
                       arr[j+2] = temp;
                   }
               }
           }
           System.out.println("希尔排序第二轮："+ Arrays.toString(arr));
   
           //第三轮
           temp = 0;
           //希尔排序的第一轮排序
           for (int i = 1; i <arr.length ; i++) {
               for (int j =i-1; j >=0; j-=1) {//前五个数因为前面没有数字，所以不进行交换。
                   if (arr[j]>arr[j+1]){
                       //交换
                       temp = arr[j];
                       arr[j] = arr[j+1];
                       arr[j+1] = temp;
                   }
               }
           }
           System.out.println("希尔排序第三轮："+ Arrays.toString(arr));*/
       }
   }
   ```

交换法很麻烦，效率低。



2. 移动法

   ```
   public static void shellSort2(int[] arr){
       //增量gap
       for (int gap = arr.length/2; gap >0 ; gap=gap/2) {
           //从第gap个元素开始
           for (int i = 0; i < arr.length; i++) {
               int j = i;
               int temp = arr[j];
               if (arr[j]<arr[j-gap]){
                   while (j-gap>=0&&temp<arr[j-gap]){
                       //
                       arr[j] = arr[j-gap];
                       j-=gap;
                   }
                   arr[j] = temp;
               }
           }
       }
   }
   ```

## 快速排序（Quicksort）

思路：快速排序是对于冒泡排序的一种改进。**基本思路**是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的数据要比另一部分的所有数据都要小，然后再按照此方法对这两部分的数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。

![image-20220331144553010](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220331144553010.png)

代码实例:

1.某种更好理解的代码

```
public static void Quick_Sort(int[] arr, int begin, int end) {
    if (begin > end)
        return;
    int tmp = arr[begin];
    int i = begin;
    int j = end;
    while (i != j) {
        while (arr[j] >= tmp && j > i)
            j--;
        while (arr[i] <= tmp && j > i)
            i++;
        if (j > i) {
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[begin] = arr[i];
    arr[i] = tmp;
    Quick_Sort(arr, begin, i - 1);
    Quick_Sort(arr, i + 1, end);

}
```

2. 上课的实际代码

   ```
   package Sort;
   
   import java.util.Arrays;
   
   /**
    * @author 巩泽楷
    * @version 1.0
    */
   public class QuickSort {
       public static void main(String[] args) {
           int[] arr = {-9, 78, 0, 23, -567, 70};
           System.out.println(Arrays.toString(arr));
           //quickSort(arr, 0, arr.length - 1);
           System.out.println("第二种方法：");
           Quick_Sort(arr,0, arr.length-1);
           System.out.println(Arrays.toString(arr));
       }
   
       public static void quickSort(int[] arr, int left, int right) {
           int l = left;
           int r = right;
           int temp = 0;
           //pivot 中轴值
           //int pivot = arr[(left + right) / 2];
           int pivot = arr[left];
           //while的目的是让比pivot的值小放到左边，比pivot大的放到右边。
           //第一次循环
           while (l < r) {//当左右下标到达pivot处，结束循环
               //筛选出左边大于pivot的值
               while (arr[l] < pivot && l<r) {
                   l++;
               }//l的位置
               //筛选出右边小于pivot的值
               while (arr[r] > pivot && l<r) {
                   r--;
               }//r的位置
   
               if (l >= r) {
                   break;
               }
               //交换
               temp = arr[l];
               arr[l] = arr[r];
               arr[r] = temp;
               //为了防止pivot的前一个与后一个值中有一个或两个与pivot相等，而导致死循环
               //故在发生如上情况时，进行对指针位移。使得打破循环。
               if (arr[l] == pivot) {
                   r--;//这样就不满足最基础的条件：l<r
               }
               if (arr[r] == pivot) {
                   l++;
               }
           }
   
           // 如果 l==r, 必须l++，r--，否则将栈溢出。
           if (l == r) {
               l++;
               r--;
           }
           System.out.println(Arrays.toString(arr));
           //左边进行递归递归
           if (left < r) {
               quickSort(arr, left, r);
           }
           //右边进行递归
           if (right > l) {
               quickSort(arr, l, right);
           }
       }
   }
   ```

## 归并排序(MergeSort)

基本思想：利用归并思想实现的排序方法，该算法采用了经典的分治策略（分治法将问题分成一些小的问题来进行递归求解，而治的阶段则将分的阶段得到的答案修补在一起。）

![image-20220401115842393](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220401115842393.png)

这种方法的重点在于“治”的阶段

我们需要将两个已有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列合并成最终序列[1,2,3,4,5,6,7,8], 如下图

![image-20220401121937144](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220401121937144.png)

代码实列：

```
package Sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

/**
 * @author 巩泽楷
 * @version 1.0
 * 归并排序
 */
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random()*80000);
        }
        //int arr[] = {8,4,5,7,1,3,6,2};
        int temp[] = new int[arr.length];
        Date date1 = new Date();    //时间类
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是："+date1Str);

        mergeSort(arr,0,arr.length-1,temp);

        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是："+date2Str);
        //System.out.println(Arrays.toString(arr));
    }
    //分解方法:
    public static void mergeSort(int[] arr, int left, int right, int[] temp){
        if (left<right){
            int mid = (left+right)/2;
            //向左递归分解
            mergeSort(arr,left,mid,temp);
            //向右的递归分解
            mergeSort(arr,(mid+1),right,temp);
            //合并
            merge(arr,left,mid,right,temp);
        }


    }
    //合并方法
    /*
        1.arr排序的原始数组
        2.left 左边有序序列的初始索引
        3.mid 中间的索引
        4.right 右边的索引
        5.temp 作为中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[]temp){
        int i = left;
        int j = mid+1;
        int t = 0;//中转数组的索引

        //(一)
        //先把左右两边(有序)的数据按照规则填充到temp数组。
        //直到其中一边处理完为止。
        while (i<=mid&&j<=right){
            if (arr[i]<=arr[j]){//左边的小于或等于右边的元素
                temp[t] = arr[i];
                t++;
                i++;
            }else {//右边的小于或等于左边的元素
                temp[t] = arr[j];
                t++;
                j++;
            }
        }

        //(二)
        //把剩余的数据依次填充到temp中。
        while (i<=mid&&i>=0){
            temp[t] = arr[i];
            t++;
            i++;
        }
        while (j>=mid&&j<=right){
            temp[t] = arr[j];
            t++;
            j++;
        }

        //(三)
        //将temp的数组拷贝到arr
        //注意：并不是每一次拷贝都将所有的数据。
        t = 0;
        int tempLeft = left;
        while (tempLeft<=right){
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }


    }
}
```

## 基数排序

1. **基数排序**属于“分配式排序”，又称“桶子法bucket Sort/bin sort”, 它是通过键值的各个位的值，将要排序的元素分配至某些"桶"中，从而达到排序的作用。
2. 基数排序属于稳定性排序，基数排序法是效率高的稳定性排序法。
3. 基数排序(Radix Sort)是桶排序的扩展。
4. 实现原理：**将整数按位数切割成不同的数字，然后按照每个位数进行比较**。
4. 缺陷：不能比较负数。需要对于代码进行改写。

基本思想：

1. 将所有带比较的数值统一为同样的数位长度，数位**较短的数前面补0**。然后，从最低位开始，依次进行一次排序。这样从最低为开始一直到最高位排序完成后，数列就变成一个有序序列。

2.  ![image-20220411132022067](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220411132022067.png)

   ![image-20220411132055545](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220411132055545.png)

​					![image-20220411132129132](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220411132129132.png)

![image-20220411132214250](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220411132214250.png)

```
package Sort;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class RadixSort {
    public static void main(String[] args) {
        int arr[] = {53,3,542,748,14,214};
        radixSort(arr);
    }
    //基数排序方法
    public static void radixSort(int[] arr){

        //根据下面的三个循环，可以推导得出最终的基数排序代码
        //因为循环的次数取决于数字的位数
        //1.得到数组中最大的数的位数
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i]>max){
                max = arr[i];
            }
        }
        //得到最大数是几位。
        int[][] bucket = new int[10][arr.length];
        int[] bucketElementCounts = new int[10];
        int maxLength = (max+"").length();//int+String会将数据类型转换为String
        for (int i = 0, n=1; i <maxLength ; i++, n*=10) {

            //将数据放到桶里
            for (int j = 0; j < arr.length; j++) {
                int digitOfElement = arr[j] / n % 10;
                //放到对应的桶里面
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            int index = 0;

            //将桶里的数据放回数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中有数据，我们才放到原数组
                if (bucketElementCounts[k] != 0) {//表示内部有数据
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出桶中的元素放到arr
                        arr[index] = bucket[k][l];
                        index++;
                    }
                }
                //第l轮后，将bucketElementCounts[k]=0，以保证下一轮循环
                bucketElementCounts[k] = 0;
            }
            System.out.println("第" + (i+1) + "轮排序=" + Arrays.toString(arr));
        }

//        //第1轮
//        //定义一个二维数组，表示10个桶，每个桶就是一个数组
//        //1.二维数组包含10个一维数组
//        //2.为了防止数据溢出，则每一个桶的大小定位arr.length
//        //3.基数排序是用空间换时间的经典算法。
//        int[][] bucket = new int[10][arr.length];
//        //为了定义每个桶中实际上存放了多少数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数
//        int[] bucketElementCounts = new int[10];
//        for (int i = 0; i < arr.length; i++) {
//            //取出每个元素在个位数的值
//            int digitOffElement = arr[i]%10;
//            //将每个数字放入对应个位数的桶当中。
//            //原因：1.在bucket[x][y]中，x代表的是第几个桶，即为个位数的数字
//            //2.y则代表在这个二维数组中的一维数组存放到了第几个数据。
//            //即表示在该值的内部一维数组中占第几个。
//            //例如：当x=1，有一个数字存放到内部的一维数组内，
//            // bucketElementCounts[1] 是表示该位置已经存放了几个值。
//            //!!!!!!!!
//            bucket[digitOffElement][bucketElementCounts[digitOffElement]] = arr[i];
//            bucketElementCounts[digitOffElement]++;
//        }
//        //按照桶的顺序(一维数组的下标依次取出数据，并放入原来的数组)
//        int index = 0;
//        for (int k = 0; k < bucketElementCounts.length; k++) {
//            //如果桶中有数据，我们才放到原数组
//            if (bucketElementCounts[k]!=0){//表示内部有数据
//                for (int l = 0; l < bucketElementCounts[k]; l++) {
//                    //取出桶中的元素放到arr
//                    arr[index] = bucket[k][l];
//                    index++;
//                }
//            }
//            //第l轮后，将bucketElementCounts[k]=0，以保证下一轮循环
//            bucketElementCounts[k] = 0;
//        }
//
//        //System.out.println(Arrays.toString(arr));
//
//        //第二轮
//        //为了定义每个桶中实际上存放了多少数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数
//
//        for (int i = 0; i < arr.length; i++) {
//            //取出每个元素在个位数的值
//            int digitOffElement = arr[i]/10%10;
//            //将每个数字放入对应个位数的桶当中。
//            //原因：1.在bucket[x][y]中，x代表的是第几个桶，即为个位数的数字
//            //2.y则代表在这个二维数组中的一维数组存放到了第几个数据。
//            //即表示在该值的内部一维数组中占第几个。
//            //例如：当x=1，有一个数字存放到内部的一维数组内，
//            // bucketElementCounts[1] 是表示该位置已经存放了几个值。
//            //!!!!!!!!
//            bucket[digitOffElement][bucketElementCounts[digitOffElement]] = arr[i];
//            bucketElementCounts[digitOffElement]++;
//        }
//        //按照桶的顺序(一维数组的下标依次取出数据，并放入原来的数组)
//        index = 0;
//        for (int k = 0; k < bucketElementCounts.length; k++) {
//            //如果桶中有数据，我们才放到原数组
//            if (bucketElementCounts[k]!=0){//表示内部有数据
//                for (int l = 0; l < bucketElementCounts[k]; l++) {
//                    //取出桶中的元素放到arr
//                    arr[index] = bucket[k][l];
//                    index++;
//                }
//
//            }
//            bucketElementCounts[k] = 0;
//        }
//        //System.out.println(Arrays.toString(arr));
//
//        //第三轮
//        for (int i = 0; i < arr.length; i++) {
//            //取出每个元素在个位数的值
//            int digitOffElement = arr[i]/100%10;
//            //将每个数字放入对应个位数的桶当中。
//            //原因：1.在bucket[x][y]中，x代表的是第几个桶，即为个位数的数字
//            //2.y则代表在这个二维数组中的一维数组存放到了第几个数据。
//            //即表示在该值的内部一维数组中占第几个。
//            //例如：当x=1，有一个数字存放到内部的一维数组内，
//            // bucketElementCounts[1] 是表示该位置已经存放了几个值。
//            //!!!!!!!!
//            bucket[digitOffElement][bucketElementCounts[digitOffElement]] = arr[i];
//            bucketElementCounts[digitOffElement]++;
//        }
//        //按照桶的顺序(一维数组的下标依次取出数据，并放入原来的数组)
//        index = 0;
//        for (int k = 0; k < bucketElementCounts.length; k++) {
//            //如果桶中有数据，我们才放到原数组
//            if (bucketElementCounts[k]!=0){//表示内部有数据
//                for (int l = 0; l < bucketElementCounts[k]; l++) {
//                    //取出桶中的元素放到arr
//                    arr[index] = bucket[k][l];
//                    index++;
//                }
//
//            }
//        }
//        System.out.println(Arrays.toString(arr));
    }

}
```

```
public class RadixSort {
    public static void main(String[] args) {
        //int arr[] = {53,3,542,748,14,214};
        int[] arr = new int[800000];
        for (int i = 0; i < 800000; i++) {
            arr[i] = (int) (Math.random()*8000000);
        }

        //System.out.println(Arrays.toString(arr));
        Date date1 = new Date();    //时间类
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(date1);
        System.out.println("排序前的时间是："+date1Str);

        radixSort(arr);

        Date date2 = new Date();
        String date2Str = simpleDateFormat.format(date2);
        System.out.println("排序后的时间是："+date2Str);


    }
```

## 排序算法的总结

![image-20220402202233420](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220402202233420.png)

# 查找



## 线性查找

代码实例：

```
package Search;

/**
 * @author 巩泽楷
 * @version 1.0
 * 线性查找
 */
public class SeqSearch {
    public static void main(String[] args) {
        int arr[] = {1,9,11,-1,34,89};
        int index = seqSearch(arr,11);
        if (index !=0){
            System.out.println("已找到");
        }else {
            System.out.println("未找到");
        }

    }

    public static int seqSearch(int[] arr, int value){
        //线性查找是逐一对比，发现有相同的值，就返回下标。
        for (int i = 0; i < arr.length; i++) {
            if (arr[i]==value){
                return i;
            }
        }
        return 0;

    }
}
```

## 二分查找

思路分析：

1. 首先确定该数组中间的下标                        mid = (left+right)/2

2. 然后让查找的数findVal与arr[mid]进行比较  

* findVal>arr[mid]向右进行递归查找

* findVal<arr[mid]向左进行递归查找

* findVal=arr[mid]找到
* 找不到，返回。

**一般情况的代码实例：**

```
package Search;

/**
 * @author 巩泽楷
 * @version 1.0
 * 二分查找
 */
public class BinarySearch {
    public static void main(String[] args) {
        //二分查找的数组必须有序
        int arr[] = {1,8,10,89,1000,1234};
        int resIndex = binarySearch(arr,0,arr.length,1);
        System.out.println("resIndex="+resIndex);
    }
    public static int binarySearch(int[] arr, int left, int right, int findVal){
        int mid = (left+right)/2;
        int midVal = arr[mid];

        if (findVal<arr[mid]){
            //左边进行递归
            System.out.println("左递归"+mid);
            return binarySearch(arr,left,mid,findVal);
        }else if (findVal>arr[mid]){
            System.out.println("右递归"+mid);
            return binarySearch(arr,mid+1,right,findVal);
        }else if (findVal==arr[mid]){
            return mid;
        }else {
            return -1;
        }

    }
}
```

但是当数组中出现重复数字时，怎么把它们全部都找出来？

对于上面代码进行修改：

```
public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
    int mid = (left+right)/2;
    int midVal = arr[mid];

    if (left>right){
        return new ArrayList<Integer>();
    }

    if (findVal<arr[mid]){
        //左边进行递归
        //System.out.println("左递归"+mid);
        return binarySearch2(arr,left,mid-1,findVal);
    }else if (findVal>arr[mid]){
        //右递归
        //System.out.println("右递归"+mid);
        return binarySearch2(arr,mid+1,right,findVal);
    }else if (findVal==arr[mid]){
        //如果不修改的情况下，只会找到重复值中距离mid较近的那一个值重复值。
        //如果要进行修改，那么我们需要寻找arr[mid]后的值是否与之重复。
        ArrayList<Integer> restIndexList = new ArrayList<>();//用于存放重复数的下标
        //在向左遍历时
        int temp = mid-1;
        while(true){
            if (temp<0||arr[temp]!=findVal){
                break;
            }
                restIndexList.add(temp);
                temp--;
        }
        restIndexList.add(mid);//把中间的加上去！！！
        temp = mid+1;
        //向右遍历
        while (true){
            if (temp>arr.length-1||arr[temp]!=findVal){
                break;
            }
                restIndexList.add(temp);
                temp++;
        }

        return restIndexList;
    }else {
        return new ArrayList<Integer>();
    }

}
```

## 插值查找

原理介绍：

1. 插值查找算法类似于二分查找，不同的是插值查找每一次从自适应的mid处开始查找。

2. 将折半查找中的mid索引的公式，low表示左边的索引，high表示右边的索引。

   ![image-20220419104337701](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220419104337701.png)

* key代表要查找的值。

```
package Search;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 * 插值查找
 */
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i+1;
        }
        System.out.println(Arrays.toString(arr));
        int index = insertValueSearch(arr,0,arr.length-1,100);
        System.out.println(index);
    }


    //插值插值算法
    //默认数组已经排序，顺序从小到大
    public static int insertValueSearch(int[] arr, int left, int right, int findVal){
        System.out.println("查找次数");
        //判断, 防止mid越界
        if(left>right||findVal<arr[0]||findVal>arr[arr.length-1]){
            return -1;
        }
        int mid = left +(right+left)*(findVal-arr[left])/(arr[right]-arr[left]);
        int midVal = arr[mid];
        if (findVal>midVal){//当findVal大于midVal时，需要向右递归
            return insertValueSearch(arr, mid+1,right,findVal );
        }else if (findVal<midVal){//当findVal小于midVal时，需要向左递归
            return insertValueSearch(arr,left,mid-1,findVal);
        }else if (midVal == findVal){
            return mid;
        }else {
            System.out.println("不存在寻找数字"+findVal);
            return -1;
        }

    }
}
```

注意：1. 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找速度较快。

2. 在关键字分布不均匀的情况下，该方法不一定比折半查找要好。



## 斐波那契查找算法

原理：原理与二分查找和插值插值类似，仅仅改变了中间的结点mid的位置，mid不再是中间或插值得到，而是位于黄金分割点附近。 mid = low+F(k-1)-1. F表示斐波那契数列

![image-20220419121935119](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220419121935119.png)

# Hash Table（哈希表）

## 基本介绍

哈希表(Hash Table):是根据关键码值（key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度。**这个映射函数叫做散列函数**，存放记录的数组叫做**散列表（Hash Table）**。

![image-20220421223740693](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220421223740693.png)

利用Hash Table来管理雇员信息

模型：

![image-20220421224509919](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220421224509919.png)

简单点来说，就是建立一个HashTable的类，类中的元素是EmpLinkedList，是一个链表，而这个链表的头节点连接着一个被称为Emp的类。有点像，目录，章节，具体页数的感觉。

```
package HashTable;

import java.util.Scanner;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class HashTableDemo {
    public static void main(String[] args) {
        HashTab hashTab = new HashTab(7);

        //创建菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true){
            System.out.println("add: 添加雇员");
            System.out.println("list: 遍历链表");
            System.out.println("find: 查找雇员");
            System.out.println("exist:退出链表");

            key = scanner.next();
            switch (key){
                case "add":
                    System.out.println("输入雇员ID：");
                    int id = scanner.nextInt();
                    System.out.println("输入雇员姓名：");
                    String name = scanner.next();
                    //创建雇员
                    Emp emp = new Emp(id,name);
                    hashTab.add(emp);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "find":
                    int empId = scanner.nextInt();
                    hashTab.findEmpId(empId);
                    break;
                case "exist":
                    scanner.close();
                    System.exit(0);//终止当前运行的程序
                default:
                    break;
            }
        }
    }
}
//表示雇员信息的类
class Emp{
    public int id;
    public String name;
    public Emp next; //初始化默认为空
    //构造器
    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

// 创建HashTable类
class HashTab{
    private EmpLinkedList[] empLinkedListArray;
    private int size;

    //Construction


    public HashTab(int size) {
        this.size = size;
        //初始化存储链表的数组
        empLinkedListArray = new EmpLinkedList[size];
        //注意分别初始化每一条链表。
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    //添加雇员
    public void add(Emp emp){
        // 根据员工的ID，将该员工添加到相应的链表上
        int empNum = hashFun(emp.id);
        empLinkedListArray[empNum].add(emp);
    }

    //遍历
    public void list(){
        for (int i = 0; i < size; i++) {
            empLinkedListArray[i].list(i);
        }
    }

    //查找方法
    public void findEmpId(int id){
        //使用散列函数确定走到那一条链表
        int empLinkedListID = hashFun(id);//通过hashFun方法确定链表所在位置
        Emp emp = empLinkedListArray[empLinkedListID].findID(id);
        if (emp!=null){
            System.out.println("在第"+empLinkedListID+"找到该链表。");
        }else {
            System.out.println("没有找到。");
        }
    }

    //使用取模法编写映射函数。目的是确定添加到那一条链表。
    public int hashFun(int id){
        return id % size;
    }

}

//表示存储Emp的链表
class  EmpLinkedList{
    //头节点直接指向Emp
    private Emp head;

    //添加雇员到链表时
    public void add(Emp emp){
        //判断是否是头节点
        if(head == null){
            head = emp;
            return;
        }
        //否则
        Emp temp = head;
        while (true){//保证每一次遍历会将emp加到链表的末尾。
            if (temp.next != null){
                temp = temp.next;
            }else {
                break;
            }
        }
        temp.next = emp;

    }
    //遍历链表
    public void list(int no){
        //当链表为空时
        if (head == null){
            System.out.println("第"+no+"链表为空");
            return;
        }
        System.out.print("第"+no+"链表为:");
        //当链表不为空时
        Emp temp =  head;
        while (true){
            System.out.println("ID= "+temp.id+" "+"Name= "+temp.name);
            if (temp.next == null){
                break;
            }
            temp = temp.next;
        }
        //System.out.println();
    }

    //查找方法
    public Emp findID(int id){
        //判断链表是否为空
        if (head==null){
            System.out.println("链表为空");
            return null;
        }
        //辅助指针
        Emp temp = head;
        while (true){
            if (temp.id == id){
                break;//跳出该循环。
            }
            //退出
            if (temp.next == null){
                temp = null;
                break;
            }
            temp = temp.next;
        }
        return temp;
    }
}
```



# 树

原因：

![image-20220423014149889](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220423014149889.png)

## 树结构的基础

![image-20220423105723149](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220423105723149.png)

## 二叉树

1. 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
2. 二叉树的子节点分为左节点和右节点。
3. 如果该二叉树的所有叶子节点都在最后一层，并且节点总数在2^n-1,  n为层数，则我们称为满二叉树。
4. 如果二叉树的所有叶子节点都在最后一层或者倒数第二层，而且**最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续**，我们称为完全二叉树。

![image-20220423141033155](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220423141033155.png)

### 二叉树的前序中序后序遍历

前序遍历：先输出父节点，再遍历左子树和右子树。

中序遍历：先遍历左子树，再输出父节点，再遍历右子树。

后序遍历：先遍历左子树，再遍历右子树，最后输出父节点。

 **分析遍历步骤：**

1. 创建一颗二叉树

2. 前序遍历
   1. 先输出当前节点（初始时候是root节点）
   2. 如果左子节点不为空，则递归将继续前序遍历
   3. 如果右子节点不为空，则递归继续前序遍历
3. 中序遍历
   1. 如果当前节点的左子节点不为空，则递归将继续中序遍历。
   2. 输出当前节点。
   3. 如果当前节点的右子节点不为空，则递归继续中序遍历。
4. 后序遍历
   1. 如果当前节点的左子节点不为空，则递归将继续中序遍历。
   2. 如果当前节点的右子节点不为空，则递归继续前序遍历。
   3. 输出当前节点。

```
package Tree;

/**
 * @author 巩泽楷
 * @version 1.0
 * 二叉树的前序，中序，后序遍历
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //创建一颗二叉树
        BinaryTree binaryTree  = new BinaryTree();
        //创建所需要的节点
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");
        HeroNode node5 = new HeroNode(5,"关胜");


        //说明：我们先手动创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);//确定根节点

        //前序遍历
        System.out.println("前序遍历");
        binaryTree.preOrder();
        //中序遍历
        System.out.println("中序遍历");
        binaryTree.midOrder();
        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder();

    }
}

//这是二叉树的类
class BinaryTree{
    private HeroNode root;//根节点
    public void setRoot(HeroNode root){
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }

    //中序遍历
    public void midOrder(){
        if (this.root!=null){
            this.root.midOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }

    //后序遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }
}
//节点类
class HeroNode{
    private int no;
    private String name;
    private HeroNode left; //默认null
    private HeroNode right; //默认null

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode: " +
                "no=" + no +
                ", name='" + name + '\'' ;
    }
    //编写前序遍历的方法
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void midOrder(){
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.midOrder();
        }
        System.out.println(this);//先输出父节点
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.midOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.postOrder();
        }
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);//先输出父节点
    }
}
```

### 前序中序后序查找

思路分析

1. 
2. 前序查找思路：
   1. 先判断当前节点的no是否是要查找的。
   2. 如果是相等，则返回当前节点。
   3. 如果不相等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找。
   4. 如果左递归前序查找，找到节点，则返回，否则继续判断，当前节点右节点是否为空，如果不为空，则继续向右递归前序查找。
3. 中序查找思路：
   1. 先判断当前节点的左子节点是否是要查找的，如果不为空，则递归中序查找。
   2. 如果找到，则返回对应的节点。如果没有找到，就和当前节点进行比较，如果是，则返回当前节点，不是则继续向右递归进行中序查找。
   3. 进行向右递归的中序查找，找到就返回，没找到就返回null。
4. 后序查找思路：
   1. 判断当前节点的左子节点是否为空，如果不为空，则进行递归中的后序查找。
   2. 如果找到，则返回对应的节点。如果没有找到，就判断当前节点的右子节点是否为空 ，



### 二叉树的删除节点（不考虑顺序）

要求：

1. 如果删除的是节点的叶子节点，则删除该节点
2. 如果删除的节点是非叶子节点，则删除该子树

思路分析:

1. 首先考虑是否为空树或只有一个root节点，root = null.
2. 因为我们的二叉树是单向的，所有我们是判断当前节点的子节点是否需要删除节点，而不能判断当前节点是否需要删除（否则无法删除该节点形成的子树）
3. 如果当前节点的左子节点不为空，判断左子节点是否目标需要删除的节点，如果是，就将this.left = null; 并且返回。如果不是，执行步骤5.
4. 如果当前节点的右子节点不为空，判断右子节点是否目标需要删除的节点，如果是，就将this.right = null; 并且返回。如果不是，执行步骤5.
5. 如果第3，4步没有删除节点，那么我们需要向左递归删除
6. 如果第5步也没有删除节点，则向右子树递归删除。

* **画个图按照流程和代码走一遍就好，文字说明不是很容易理解**

### 基础二叉树代码实列

```
package Tree;

/**
 * @author 巩泽楷
 * @version 1.0
 * 二叉树的前序，中序，后序遍历
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        //创建一颗二叉树
        BinaryTree binaryTree  = new BinaryTree();
        //创建所需要的节点
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");
        HeroNode node5 = new HeroNode(5,"关胜");


        //说明：我们先手动创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);//确定根节点

        //前序遍历
        System.out.println("前序遍历");
        binaryTree.preOrder();
        //中序遍历
        System.out.println("中序遍历");
        binaryTree.midOrder();
        //后序遍历
        System.out.println("后序遍历");
        binaryTree.postOrder();

        //前序查找
     /*   System.out.println("前序查找方式：");
        HeroNode resNode = binaryTree.preOrderSearch(5);
        if (resNode!=null){
            System.out.println("存在有"+resNode.getName()+" "+resNode.getNo());
        }else {
            System.out.println("没有找到");
        }*/

        //中序查找
    /*    System.out.println("前序查找方式：");
        HeroNode resNode = binaryTree.midOrderSearch(5);
        if (resNode!=null){
            System.out.println("存在有"+resNode.getName()+" "+resNode.getNo());
        }else {
            System.out.println("没有找到");
        }*/

        //后序查找
    /*  System.out.println("后序查找方式：");
        HeroNode resNode = binaryTree.postOrderSearch(5);
        if (resNode!=null){
            System.out.println("存在有"+resNode.getName()+" "+resNode.getNo());
        }else {
            System.out.println("没有找到");
        }*/


        //删除3号节点
        System.out.println("删除节点");
        binaryTree.preOrder();
        binaryTree.delNode(3);
        System.out.println("删除五号节点后：");
        binaryTree.preOrder();

    }
}

//这是二叉树的类
class BinaryTree{
    private HeroNode root;//根节点
    public void setRoot(HeroNode root){
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }

    //中序遍历
    public void midOrder(){
        if (this.root!=null){
            this.root.midOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }

    //后序遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法遍历。");
        }
    }


    //前序查找
    public HeroNode preOrderSearch(int no){
        if (root!=null){
            return root.preOrderSearch(no);
        }else {
            System.out.println("链表为空");
            return null;
        }
    }

    //中序查找
    public HeroNode midOrderSearch(int no){
        if (root!=null){
            return root.midOrderSearch(no);
        }else {
            System.out.println("链表为空");
            return null;
        }
    }

    //后序查找
    public HeroNode postOrderSearch(int no){
        if (root!=null){
            return root.postOrderSearch(no);
        }else {
            System.out.println("链表为空");
            return null;
        }
    }

    public void delNode(int no){
        //1.首先考虑是否为空树或只有一个root节点，root = null.
        if (root!=null){
            if (root.getNo()==no){
                root = null;
            }else {
                //递归删除
                root.delNode(no);
            }
        }else {
            System.out.println("空树，不删除。");
        }
    }
}
//节点类
class HeroNode{
    private int no;
    private String name;
    private HeroNode left; //默认null
    private HeroNode right; //默认null

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode: " +
                "no=" + no +
                ", name='" + name + '\'' ;
    }
    //编写前序遍历的方法
    public void preOrder(){
        System.out.println(this);//先输出父节点
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
    //中序遍历
    public void midOrder(){
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.midOrder();
        }
        System.out.println(this);//先输出父节点
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.midOrder();
        }
    }
    //后序遍历
    public void postOrder(){
        //递归向左子树进行遍历
        if (this.left!=null){
            this.left.postOrder();
        }
        //递归向右子树进行遍历
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);//先输出父节点
    }

    //前序遍历查找
    public HeroNode preOrderSearch(int no){
        System.out.println("前序排序————————");
        //比较当前节点
        if (this.no == no){
            return this;   //返回出这次循环
        }
        //1.判断当前节点是否为空，如果不为空，则递归前序查找。
        //2.如果左递归前序查找，找到节点，则返回。
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    //中序遍历查找
    public HeroNode midOrderSearch(int no){

        //比较当前节点的左节点
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.midOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        System.out.println("中序查找-------");
        if (this.no == no){
            return this;   //返回出这次循环
        }
        if (this.right!=null){
            resNode = this.right.midOrderSearch(no);
        }
        return resNode;
    }
    //后序遍历查找
    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        if (this.right!=null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        System.out.println("后序查找————————");
        if (this.no == no){
            return this;   //返回出这次循环
        }
        return resNode;
    }
    /*
    `1. 首先考虑是否为空树或只有一个root节点，root = null.
    `2. 因为我们的二叉树是单向的，所有我们是判断当前节点的子节点是否需要删除节点，而不能判断当前节点是否需要删除（否则无法删除该节点形成的子树）
    `3. 如果当前节点的左子节点不为空，判断左子节点是否目标需要删除的节点，如果是，就将this.left = null; 并且返回。如果不是，执行步骤5.
    `4. 如果当前节点的右子节点不为空，判断右子节点是否目标需要删除的节点，如果是，就将this.right = null; 并且返回。如果不是，执行步骤5.
    `5. 如果第3，4步没有删除节点，那么我们需要向左递归删除？
    `6. 如果第5步也没有删除节点，则向右子树递归删除。
     */

    public void delNode(int no){
        //1.首先考虑是否为空树或只有一个root节点，root = null.但节点没有root，在BinaryTree中实现该步骤

        //3.如果当前节点的左子节点不为空，判断左子节点是否目标需要删除的节点，如果是，就将this.left = null; 并且返回。
        if (this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        //4.如果当前节点的右子节点不为空，判断右子节点是否目标需要删除的节点，如果是，就将this.right = null; 并且返回。
        if (this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        //5.如果第3，4步没有删除节点，那么我们需要向左递归删除
        if (this.left!=null){
            this.left.delNode(no);
        }
        //6.如果第5步也没有删除节点，则向右子树递归删除。
        if (this.right!=null){
            this.right.delNode(no);
        }
    }
}
```

### 顺序存储二叉树

​	从数据存储来看，数组的存储方式和树的存储方式可以互相转换，即数组可以转换为树，树可以转换为数组。那么，我们如何在树以数组的形式存储时，在遍历该数组时，仍可以以前序，中序，后序的方式对数组进行遍历？

![image-20220425095254453](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425095254453.png)



![image-20220425095404163](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425095404163.png)

**这里的n都是在数组中的元素下标**

### 线索化二叉树

#### 基本介绍

1. n个结点的二叉树表中含有n+1[公式：2n-(n-1)=n+1]个空指针域**（指在构成二叉树时，有些节点没有指向左右节点，而留下的空域）**。利用二叉链表的空指针域，存放指向指向该结点在**某种遍历次序**下的前驱和后续结点的指针。
2. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为**线索化二叉树(Threaded Binary Tree)**。根据线索性质的不同，线索化二叉树可以分为前序二叉树，中序二叉树和后序二叉树三种。
3. 一个结点的前一个结点，称为**前驱节点**
4. 一个结点的后一个结点，称为**后序节点**

例子：

![image-20220509102902443](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220509102902443.png)

按照遍历结果，很容易分辨各个节点的前驱节点和后续节点。

**代码实例：**







### 堆排序(不太会)

#### 基本介绍

1. 堆排序是利用堆这一数据结构而设计出的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为**O(nlogn)**,它也是不稳定排序。

2. 堆是具有以下性质的**完全二叉树**：每个节点的值都大于或者等于其左右孩子节点的值，称为大顶堆，注意：**没有要求节点的左值和右值的大小关系**

3. 每个节点的值都小于或等于其左右节点的值，称为**小顶堆**。

4. 大顶堆举例说明

   ![image-20220425120150411](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425120150411.png)

5. 小顶堆举例说明

   ![image-20220425120438335](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425120438335.png)



#### 基本思想

1. 将待排序的序列构成一个大顶堆
   1. 关键在于如何构成一个大顶堆！！！
2. 此时，整个序列的最大值就是堆顶的根节点
3. 将末尾元素进行交换，此时末尾就为最大值。
4. 然后将剩余n-1个元素重新构成一个堆，这样会得到n个元素的次小值。如此反复执行，就可以得到一个有序序列。

* 每一次构成大顶堆会把当前元素的最大值取出来，放到数组的末尾。如此往复，可以得到一个有序序列。

```
import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 * 堆排序
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {4,6,8,5,9};
        heapSort(arr);
    }
    public static void heapSort(int[] arr){
        int temp = 0;
        System.out.println("堆排序：");
        //
        for (int i = arr.length/2-1; i>=0; i--) {
            adjustHeap(arr,i,arr.length);
        }
        for (int j = arr.length-1; j >0; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0,j);
        }
        System.out.println(Arrays.toString(arr));
    }
    //将一个数组（二叉树）调整成一个大顶堆
    public static void adjustHeap(int arr[], int i, int length){
        int temp = arr[i];
        //开始调整
        //1. j=i*2+1, j表示i的左子节点
        for (int j = i*2+1; j <length; j=j*2+1) {
            if (j+1<length && arr[j]<arr[j+1]){//说明左子节点的值小于右子节点的值
                j++; //j指向右子节点
            // 首先对于目标节点的左右子节点进行对比，选出更大的数。
            }
            //将选出的更大的数与节点进行比较
            if (arr[j]>temp){
                arr[i] = arr[j];//把更大的值换位节点
               // arr[j] = temp;?
                i = j;
            }else {
                break;//有点不理解。
            }
            //当for循环结束后，我们将i为父节点的树的最大值放在了最顶（局部）
            arr[i] = temp;//将temp值放到temp的位置。
        }
    }
}
```

# 赫夫曼树

## 基本介绍

1. 给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的**带权路径长度（WPI）**达到最小，称这样的二叉树为**最优二叉树**，则称为哈夫曼树（Huffman Tree）或者赫夫曼树.
2. 赫夫曼树是指带权路径长度最短的树，权值较大的节点离根较近。

**概念说明：**

1. **路径**和**路径长度**：在一颗树中，从一个节点往下可以达到的子节点或子节点的子节点之间的通路，称为**路径**。通路中分支的数目称为**路径长度**，若规定根节点的层数为1，则从根节点到第L层节点的路径长度为L-1.
2. **节点的权和带权路径长度**：若将树中的节点赋给一个有着某种特殊意义的数值，则称这个节点为该**节点的权**。节点的带权路径长度为：**从根节点到该节点之间的路径长度与该节点的权的乘积**。
3. 树的带权路径长度：树的带权路径长度规定所有的**叶子节点**的带权路径长度之和，记为WPI（weighted path length），**权值越大的节点离根节点越近的二叉树才是最优二叉树。**
4. ![image-20220425210226382](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425210226382.png)

* 第二个图是赫夫曼树

![image-20220425210842931](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425210842931.png)

**思路分析：**

1. 将每一个数据从小到大进行排序，每一个数据都是一个节点，每一个节点可以视作一个最简单的二叉树。
2. 取出根节点权值最小的两颗二叉树
3. 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树的根节点权值的和。
4. 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1，2，3，4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。

图示：

第一步：

![image-20220425213447197](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425213447197.png)

第二步：

![image-20220425213524726](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425213524726.png)

结果：

![image-20220425213840597](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220425213840597.png)

```
package huffmantree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13,7,8,3,29,6,1};
        Node root = createHuffmanTree(arr);
        //测试
        preOrder(root);
    }

    //Create HuffmanTree
    public static Node createHuffmanTree(int[] arr){
        //为了便于操作
        //1.遍历arr数组
        //2.将arr的每个元素构成一个Node
        //3.再将Node放入到ArrayList
        List<Node> nodes = new ArrayList<>();
        for (int value :arr) {
            nodes.add(new Node(value));

        }

        while (nodes.size()>1){
            //排序，从小到大(因为实现了CompareTo的接口)
            Collections.sort(nodes);
            System.out.println("Nodes = "+nodes);

            //取出权值最小的节点组成二叉树
            //1.取出权值最小的两个节点
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);

            //3.构建一棵新的二叉树
            Node parent = new Node(leftNode.value+rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            //4.从ArrayList删除处理过的二叉树
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            //5.将parent加入nodes
            nodes.add(parent);

            // System.out.println("Nodes="+nodes);
            //再次排序
            //Collections.sort(nodes);
            // System.out.println("Nodes="+nodes);
        }
        return nodes.get(0);

    }

    //前序遍历的方法
    public static void preOrder(Node root){
        if (root!=null){
            root.preOrder();
        }else {
            System.out.println("根节点为空，是空树");
        }
    }

}
//创建节点
// 接入Comparable接口，重写compareTo方法实现比较
class Node implements Comparable<Node> {
    public int value;
    public Node left;
    public Node right;

    //前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        // 表示从小到大进行排序, 反过来的化就是从大到小
        return this.value-o.value;
    }
}
```

 ## 赫夫曼编码

### 基本介绍

1. 赫夫曼编码是一种编码方式，属于一种程序算法
2. 赫夫曼编码和赫夫曼树是在电讯通讯中的经典应用之一。
3. 赫夫曼编码广泛用于数据文件压缩。其中压缩率通常在20%~90%之间。
4. 赫夫曼编码是可变字长编码（VLC）的一种。



![image-20220426125453156](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220426125453156.png)

![image-20220426125433124](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220426125433124.png)

第三章信息处理方式：赫夫曼编码

![image-20220426131956858](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220426131956858.png)

![image-20220613103119140](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220613103119140.png)

![image-20220613103136049](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220613103136049.png)

![image-20220613103148826](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220613103148826.png)

# 二叉搜索树BST

## 二叉排序树BST的定义

二叉排序树：BST（Binary Sort（Search）Tree），对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值要小，右子节点的值比当前节点的值要大。

* 如果有相同的值，可以将该节点放在左子节点或右子节点。

## 二叉树的创建，遍历，删除

### 代码：



```
package BinarySortTree;

import java.sql.SQLOutput;

/**
 * @author 巩泽楷
 * @version 1.0
 * 二叉搜素树BST的构建，遍历和删除
 */
public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();

        //循环添加节点到二叉树
        for (int i = 0; i < arr.length; i++) {
            //直接新建节点
            binarySortTree.add(new Node(arr[i]));
        }

        //中序遍历二叉树
        System.out.println("中序遍历二叉树：");
        binarySortTree.infixOrder();//1,2,3,5,7,9,10,12

        binarySortTree.delNode(2);
        binarySortTree.delNode(5);
        binarySortTree.delNode(9);
        binarySortTree.delNode(12);
        binarySortTree.delNode(7);
        binarySortTree.delNode(3);
        binarySortTree.delNode(10);
        //binarySortTree.delNode(1);

        System.out.println("经过删除叶子节点后中序遍历二叉搜素树：");
        //中序遍历二叉树
        binarySortTree.infixOrder();

    }
}


//创建二叉排序树的类
class BinarySortTree{
    //树的根节点
    private Node root;

    //添加节点的方法
    public void add(Node node){
        if (root==null){
            root = node;
        } else {
            root.add(node);
        }
    }

    //中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        } else {
            System.out.println("二叉排序树为空，无法遍历");
        }
    }

    //查找需要删除的节点
    public Node search(int value){
        if (root==null){
            System.out.println("根节点为空");
            return null;
        }else {
            return root.search(value);
        }
    }

    //查找被删除节点的父节点
    public Node searchParent(int value){
        if (root==null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**查找二叉排序树的最小值并删除
     *
     * @param node 传入的节点（二叉排序树的根节点）
     * @return 返回以node为根节点的二叉排序树的最小节点
     */
    public int delRightTreeMin(Node node){
        Node temp = node;
        //使用循环来查找左子节点，找到最小值
        while(temp.left!=null){
            temp = temp.left;
        }
        //当走出循环时，删除最小节点
        delNode(temp.value);
        return temp.value;
    }

    //删除节点
    public void delNode(int value){
        if (root==null){
            return;
        }else {
            //1.找到需要删除的节点
            Node targetNode = search(value);
            //如果没有找到需要删除的节点
            if (targetNode == null){
                System.out.println("没有找到需要删除的节点");
                return;
            }
            //如果我们发现当前这颗二叉树排序树只有一个节点
            if (root.left == null && root.right == null){
                root = null;
                return;
            }
            //2.寻找targetNode的父节点
            Node parent = searchParent(value);
            //3.开始第三步，分层多种情况讨论
            //3.1 如果要删除的节点是叶子节点
            if (targetNode.left==null && targetNode.right==null){//判断是否是叶子节点
                //判断是父节点左子节点还是右子节点
                    //判断是否是左子节点
                if (parent.left!=null && parent.left.value==value){
                    parent.left = null;

                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }

            //3.2 因为直接写比较只有一个子树的情况比较麻烦，所以先写有两个子树的节点，剩下的就只有一个子树的情况。
            }else if(targetNode.left!=null && targetNode.right!=null){
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;

            //3.3 删除只有一个子树的节点
            }else {
                //3.3.1 targetNode有左子节点，
                //两种情况，1.targetNode是parent的左子节点. 2.是右子节点
                if (targetNode.left!=null){
                    if (parent!=null) {
                        //3.3.1.1 targetNode是parent的左子节点.
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else {//3.3.1.2 targetNode是parent的右子节点.
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                //3.3.2 targetNode有右子节点，
                }else {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            //3.3.2.1 targetNode是parent的左子节点.
                            parent.left = targetNode.right;
                        } else {
                            //3.3.2.2 targetNode是parent的右子节点.
                            parent.right = targetNode.right;
                        }
                    }else{
                        root = targetNode.right;
                    }
                }

            }
        }
    }

}



//节点类
class Node{
    int value;
    Node left;
    Node right;
    //构造器
    public Node(int value){
        this.value = value;
    }


    /**
     * 查找需要删除的节点
     * @param value 希望返回的节点
     * @return
     */
    public Node search(int value){
        if (value==this.value){//成功找到该节点
            return this;
        } else if(value<this.value){//value小于当前节点的值，应该向左子树查找。
            //为了防止目标节点的左子节点为空
            if (this.left==null){
                System.out.println("Do not Find the Node");
                return null;
            }
            return this.left.search(value);//利用递归向左查找
        } else {
            //为了防止目标节点的右子节点为空
            if (this.right==null){
                System.out.println("Do not Find the Node");
                return null;
            }
            return this.right.search(value);//利用递归向左查找
        }
    }

    /**
     * 查找需要删除的节点的父节点
     * @param value 要找到的节点的值
     * @return 返回需要删除节点的父节点
     */
    public Node searchParent(int value){
        //判断父节点的子节点是否满足条件
        if((this.left!=null && this.left.value == value)
                ||(this.right!=null&&this.right.value==value)){
            return this;
        }else {
            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            //利用递归向左查找
            if (value<this.value && this.left != null){
                return this.left.searchParent(value);
            }else if (value>=this.value && this.right != null){
                //如果查找的值大于当前节点的值，并且当前节点的右子节点不为空
                //利用递归向右查找
                return this.right.searchParent(value);
            } else {//没有父节点
                System.out.println("没有找到该节点的父节点");
                return null;
            }
        }
    }


    //方法一：添加节点
    //使用递归加入节点
    public void add(Node node){
        //判断节点是否为空
        if (node==null){
            System.out.println("该节点为空，无法添加");
            return;
        }
        //判断传入节点的值和当前节点的的关系
            //在小于的情况下
        if (node.value<this.value){
            //判断node与value的子节点的关系
            if (this.left == null){
                this.left=node;
            }else {
                //递归的向左子树添加
                this.left.add(node);
            }
        } else {
            if (this.right==null){
                this.right = node;
            }else {
                //递归的向右子树添加
                this.right.add(node);
            }
        }
    }

    //中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }

        System.out.println(this);

        if (this.right!=null){
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```

### 二叉搜素树的删除

![image-20220613144502909](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220613144502909.png)

三种情况：

1.删除叶子节点(2,5,9,12)

1. 要求先找到要删除的节点 targetNode
2. 找到targetNode的父节点parent
3. 确定targetNode是parent的左子节点还是右子节点
4. 根据前面的情况来对应删除。



2.删除<font color=red>有两个子树</font>的节点（7，3，10）

1. 要求先找到要删除的节点 targetNode
2. 找到targetNode的父节点parent
3. 从targetNode的<font color='red'>右子树</font>找到最小的节点
4. 用一个临时变量temp，将最小节点的值保存
5. 删除最小节点
6. targetNode.value = temp



3.<font color='red'>只有一个子树</font>的的节点(1)

1. 要求先找到要删除的节点 targetNode
2. 找到targetNode的父节点parent
3. 确定targetNode的子节点是左子节点还是右子节点
5. 如果targetNode有左子节点

   1. targetNode是parents的左子节点。parent.left = targetNode.left
   2. targetNode是parents的右子节点。parent.right = targetNode.left
6. targetNode有右子节点

   1. targetNode是parents的左子节点。parent.left = targetNode.right
   2. targetNode是parents的右子节点。parent.right = targetNod


# 平衡二叉树AVL

## AVL的基本定义

1. AVL也叫平衡二叉搜素树，又被称为AVL树，可以保证查询效率最高（<font color='red'>在这方面与BST不同</font>）
2. 具有以下特点：它是一棵空树或者左右两个子树的高度差的绝对值不超过1，并且左右两个子树也都是平衡二叉树。平衡二叉树的实现方法有红黑树，AVL，替罪羊树，Treap，伸展树

## 平衡二叉树的左旋转和右旋转

将一棵BST变成AVL需要一些将BST树的高度进行转变，一般使用左旋转和右旋转。

不过首先要计算左右子树的高度。

### AVL的左旋转

<font color='red' size=4>当右子树的高度大于左子树</font>

1. 创建一个新的节点newNode（例子中为4），创建一个新的节点，值等于当前根节点的值。
2. 把新节点的左子树设置为了当前节点的左子树
   1. newNode.left = left
3. 把新节点的右子树设置为当前节点的右子树的左子树
   1. newNode.right = right.left
4. 把当前节点的值换成右子节点的值
   1. value = right.value
5. 把当前节点的右子树设置为当前节点的右子树的右子树
   1. right = right.right
6. 把当前节点的左子树设置为新的节点
   1. left = newleft

![image-20220617104416569](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220617104416569.png)

### AVL的右旋转

1. 创建一个新的节点newNode（以10这个值进行创建）

2. 把新节点的右子树设置为当前节点的右子树

   1. new Node.right = right

3. 把新节点的左子树设置为当前节点的左子树的右子树

   1. new Node.left = left.right

4. 把当前节点的值换成左子节点的值

   1. value = left.value

5. 把当前节点的左子树设置为左子树的左子树

   1. left = left.left

6. 把当前节点的右子树设置为新节点

   1. right = newNode

   

   ![image-20220620091517692](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220620091517692.png)

   

### AVL的双旋转

问题分析：

![image-20220620092455576](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220620092455576.png)

发现左旋转和右旋转都无法解决上述问题。

<font color='red'>原因：该图满足右旋转的条件，但是其左子树的右子树大于其左子树的高度。</font>

## AVL树的代码汇总

```
package AVLTree;



/**
 * @author 巩泽楷
 * @version 1.0
 * 关于AVL树的相关知识
 */
public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};//左旋转树
        //int[] arr = {10,12,8,9,7,6}; //右旋转二叉树
        int[] arr = {10,11,7,6,8,9};  //双旋转二叉树
        //创建一个AVLTree对象
        AVLTree avlTree = new AVLTree();
        //添加节点
        for (int i = 0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }

        //遍历
        System.out.println("中序遍历：");
        avlTree.infixOrder();
        //
        System.out.println("在平衡处理后：");
        System.out.println("树的高度="+avlTree.getRoot().height());
        System.out.println("左子树的高度="+avlTree.getRoot().leftHeight());
        System.out.println("右子树的高度="+avlTree.getRoot().rightHeight());
        ;

    }
}

class AVLTree {
    //树的根节点
    private Node root;

    public Node getRoot() {
        return root;
    }

    public void setRoot(Node root) {
        this.root = root;
    }

    //添加节点的方法
    public void add(Node node){
        if (root==null){
            root = node;
        } else {
            root.add(node);
        }
    }

    //中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        } else {
            System.out.println("二叉排序树为空，无法遍历");
        }
    }

    //查找需要删除的节点
    public Node search(int value){
        if (root==null){
            System.out.println("根节点为空");
            return null;
        }else {
            return root.search(value);
        }
    }

    //查找被删除节点的父节点
    public Node searchParent(int value){
        if (root==null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    /**查找二叉排序树的最小值并删除
     *
     * @param node 传入的节点（二叉排序树的根节点）
     * @return 返回以node为根节点的二叉排序树的最小节点
     */
    public int delRightTreeMin(Node node){
        Node temp = node;
        //使用循环来查找左子节点，找到最小值
        while(temp.left!=null){
            temp = temp.left;
        }
        //当走出循环时，删除最小节点
        delNode(temp.value);
        return temp.value;
    }

    //删除节点
    public void delNode(int value){
        if (root==null){
            return;
        }else {
            //1.找到需要删除的节点
            Node targetNode = search(value);
            //如果没有找到需要删除的节点
            if (targetNode == null){
                System.out.println("没有找到需要删除的节点");
                return;
            }
            //如果我们发现当前这颗二叉树排序树只有一个节点
            if (root.left == null && root.right == null){
                root = null;
                return;
            }
            //2.寻找targetNode的父节点
            Node parent = searchParent(value);
            //3.开始第三步，分层多种情况讨论
            //3.1 如果要删除的节点是叶子节点
            if (targetNode.left==null && targetNode.right==null){//判断是否是叶子节点
                //判断是父节点左子节点还是右子节点
                //判断是否是左子节点
                if (parent.left!=null && parent.left.value==value){
                    parent.left = null;

                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }

                //3.2 因为直接写比较只有一个子树的情况比较麻烦，所以先写有两个子树的节点，剩下的就只有一个子树的情况。
            }else if(targetNode.left!=null && targetNode.right!=null){
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;

                //3.3 删除只有一个子树的节点
            }else {
                //3.3.1 targetNode有左子节点，
                //两种情况，1.targetNode是parent的左子节点. 2.是右子节点
                if (targetNode.left!=null){
                    if (parent!=null) {
                        //3.3.1.1 targetNode是parent的左子节点.
                        if (parent.left.value == value) {
                            parent.left = targetNode.left;
                        } else {//3.3.1.2 targetNode是parent的右子节点.
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }

                    //3.3.2 targetNode有右子节点，
                }else {
                    if (parent != null) {
                        if (parent.left.value == value) {
                            //3.3.2.1 targetNode是parent的左子节点.
                            parent.left = targetNode.right;
                        } else {
                            //3.3.2.2 targetNode是parent的右子节点.
                            parent.right = targetNode.right;
                        }
                    }else{
                        root = targetNode.right;
                    }
                }

            }
        }
    }
}






//节点类
class Node{
    int value;
    Node left;
    Node right;
    //构造器
    public Node(int value){
        this.value = value;
    }

    //返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }else {
            return left.height();
        }
    }
    //返回右子树的高度
    public int rightHeight(){
        if (right == null){
            return 0;
        }else {
            return right.height();
        }
    }


    /**
     * 计算AVL树的高度
     * @return 返回以该节点为根节点的树的高度
     */
    public int height(){
        //条件?满足条件执行A :不满足条件执行B
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height())+1;
    }


    /**
     * AVL树的左旋转
     *
     */
    public void leftRotate(){
        //1. 创建新的节点
        Node newNode = new Node(value);
        //2. 把新节点的左子树设置为当前节点的左子树
        newNode.left = this.left;
        //3. 把新的节点的右子树设置为当前节点的右子树的左子树
        newNode.right = this.right.left;
        //4. 把当前节点的值替换成右子节点的值
        this.value = this.right.value;
        //5. 把当前节点的右子树设置为当前节点的右子树的右子树
        this.right = right.right;
        //6.把当前节点的左子树设置为新的节点
        this.left = newNode;
    }

    /**
     * AVL树的右旋转
     */
    public void rightRotate(){
        //1. 创建一个新的节点
        Node newNode = new Node(value);
        //2. 把新节点的右子树设置为当前节点的右子树
        newNode.right = this.right;
        //3. 把新的节点的左子树设置为当前节点的左子树的右子树
        newNode.left = this.left.right;
        //4. 把当前节点的值换成左子节点的值
        this.value = this.left.value;
        //5. 把当前节点的值换成左子节点的值
        this.left = left.left;
        //6. 把当前节点的右子树设置为新的节点
        this.right = newNode;

    }



    /**
     * 查找需要删除的节点
     * @param value 希望返回的节点
     * @return
     */
    public Node search(int value){
        if (value==this.value){//成功找到该节点
            return this;
        } else if(value<this.value){//value小于当前节点的值，应该向左子树查找。
            //为了防止目标节点的左子节点为空
            if (this.left==null){
                System.out.println("Do not Find the Node");
                return null;
            }
            return this.left.search(value);//利用递归向左查找
        } else {
            //为了防止目标节点的右子节点为空
            if (this.right==null){
                System.out.println("Do not Find the Node");
                return null;
            }
            return this.right.search(value);//利用递归向左查找
        }
    }

    /**
     * 查找需要删除的节点的父节点
     * @param value 要找到的节点的值
     * @return 返回需要删除节点的父节点
     */
    public Node searchParent(int value){
        //判断父节点的子节点是否满足条件
        if((this.left!=null && this.left.value == value)
                ||(this.right!=null&&this.right.value==value)){
            return this;
        }else {
            //如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            //利用递归向左查找
            if (value<this.value && this.left != null){
                return this.left.searchParent(value);
            }else if (value>=this.value && this.right != null){
                //如果查找的值大于当前节点的值，并且当前节点的右子节点不为空
                //利用递归向右查找
                return this.right.searchParent(value);
            } else {//没有父节点
                System.out.println("没有找到该节点的父节点");
                return null;
            }
        }
    }


    //方法一：添加节点
    //使用递归加入节点
    public void add(Node node){
        //判断节点是否为空
        if (node==null){
            System.out.println("该节点为空，无法添加");
            return;
        }
        //判断传入节点的值和当前节点的的关系
        //在小于的情况下
        if (node.value<this.value){
            //判断node与value的子节点的关系
            if (this.left == null){
                this.left=node;
            }else {
                //递归的向左子树添加
                this.left.add(node);
            }
        } else {
            if (this.right==null){
                this.right = node;
            }else {
                //递归的向右子树添加
                this.right.add(node);
            }
        }
        //进行判断，保证输出的树是AVL树
            //左旋转
        if ((rightHeight() - leftHeight())>1){
            //如果当它右子树的左子树的高度大于其右子树的右子树的高度时，使用双旋转
            if (right!=null && right.leftHeight() > right.rightHeight()){
                //对根节点的右节点进行右旋转
                right.rightRotate();
                //对根节点进行左旋转
                leftRotate();
            }else {
                leftRotate();
            }
            return ; //防止运行到下面的条件
        }
            //右旋转
        if ((leftHeight()-rightHeight())>1){
            //如果当它左子树的右子树的高度大于其左子树的左子树的高度时，使用双旋转
            if (left!=null && left.rightHeight() > left.leftHeight()){
                //对根节点的左节点进行左旋转
                left.leftRotate();
                //对根节点进行右旋转
                rightRotate();
            }else {
                rightRotate();
            }
        }
        return ;
    }

    //中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }

        System.out.println(this);

        if (this.right!=null){
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```

# 多叉树

## 二叉树的问题分析

![image-20220620094807096](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220620094807096.png)

1. 在进行二叉树的操作时，节点过多导致多次进行IO流操作，对二叉树的建立速度有影响
2. 因为节点过多，且二叉树的一个节点只能链接两个节点，导致树的高度过高，操作速度变慢。

## 多叉树

1. 在二叉树中，每个节点有数据项，最多有两个节点。如果<font color='red'>允许每个节点可以有更多的数据项和更多的子节点</font>，就是多叉树。
2. 在之后会讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，来对二叉树进行优化
3. 举例说明：

![image-20220620115728675](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220620115728675.png)

## B树

也写作B-tree树和B-树

B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。

![image-20220620120009355](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220620120009355.png)

1. 如图，B树通过重新组织节点，降低了树的高度。
2. <font color=blue>文件系统和数据库系统的设计者通过磁盘预读原理，将一个节点大小设为一个页（一页通常为4K），这样每个节点都只需要一次I/O流就可以完全载入</font>

### B树的说明

1. B树的阶： 节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶乘是4
2. B-树的搜索，从根节点开始，对节点内的关键字<font color=blue>(前提是该二叉树是有序序列）</font>进行二分查找，如果命中则结束，否则进入查询关键字所属范围的子节点；重复以上步骤，直到找到该关键字的位置或者对应的的子节点为空。
3. 关键字集合分布在整个树中，即叶子节点和非叶子节点都可以存放数据
4. 搜索可能在非叶子节点结束
5. 搜索关键字的过程等价于在全集内做一次二分查找

![image-20220622110436411](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622110436411.png)

## B+树

B+树是B树的一种变体，也是一种多路搜索树。主要特点是<font color='red'>只在叶子节点的链表中存放数据。</font>这种方法把一整串链表分成了很多段，极大的提高了检索效率。

![image-20220622110401889](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622110401889.png)

### B+树的基本说明

1. B+树的搜索和B树基本相同，区别是B+树只有达到叶子节点才能命中<font color='blue'>（即查找到目标值）</font>
2. 所有关键字都出现在<font color=red>叶子节点的链表</font>中, 且链表是有序的。
3. 查找不可能在非叶子节点命中
4. 非叶子节点相当于是叶子节点的索引，叶子节点是存储数据的数据集
5. 更适合文件索引系统
6. B树和B+树各有自己的应用场景，<font color='red'>不能说B+树一定好于B树</font>，反之亦然。

## B*树

B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟节点的指针。

1. B*树定义了非叶子节点关键字的个数，至少为(2/3)M, 即块的最低使用率为2/3, 而B+树的块的最低使用率为B+树的1/2
2. 从第一个特点可以看出，B*树分配新节点的概率比B+树要低，空间使用率更高。

![image-20220622110416241](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622110416241.png)

![image-20220622115326201](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622115326201.png)

## 2-3 树

### 2-3树基本定义

1. 2-3树的所有叶子节点都在同一层
2. <font color='red'>有两个子节点的节点叫做二节点，二节点要么没有节点，要么有两个节点</font>
3. <font color=red>有三个子节点的节点叫做三节点，三节点要么没有节点，要么有三个节点</font>

* <font color='blue'>注意2-3树也要满足BST排序树的特点（左边小，右边大）</font>

### 实例

![image-20220622103101843](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622103101843.png)

![image-20220622103134992](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622103134992.png)

![image-20220622103205437](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622103205437.png)

![image-20220622103258682](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622103258682.png)

![image-20220622103331273](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622103331273.png)





## 2-3-4树

与2-3树相同，只是多了一个四节点



# 图

## 图的基本介绍

图是一种数据结构，其中节点可以具有0个或者多个相邻元素。两个节点之间的链接称为边。节点也可以称为顶点。

## 图的常用概念

1. 顶点（Vertex）
2. 边（Edge）
3. 路径
4. 无向图
5. 有向图
6. 带权图（网）

![image-20220622150950291](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622150950291.png)

![image-20220622151023510](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622151023510.png)

## 图的表示方式

### 1. 邻接矩阵

邻接矩阵是表示图行中各个顶点之间相邻关系的矩阵，对于n个顶点而言，矩阵是row和col表示的是1......n个点

![image-20220622151318928](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622151318928.png)

### 2. 链表（邻接表）

1. 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在的，会造成空间的一定是损失。
2. 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组和链表构成。

![image-20220622152600986](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220622152600986.png)



### 代码分析

![image-20220623100258926](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220623100258926.png)



## DFS深度优先遍历

1. 深度优先遍历，从访问节点开始，初始访问节点可能有多个邻接节点，深度优先遍历的策略是首先访问第一个邻接节点，然后再以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点。可以这么理解：<font color='red'>每一次都在访问完当前节点后首先访问当前节点的第一个邻接节点。</font>
2. 深度优先遍历的访问策略是优先纵向挖掘深入，而不是对一个结点的所有邻接节点进行横向的访问。
3. 这是一个递归过程

### DFS的算法步骤

![image-20220623115007111](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220623115007111.png)

<font color='red'>在第四步中，添加语句：如果w已经被访问，则跳转到第5步。</font>

答案为：A-B-C-D-E

### DFS的代码实例

```
import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 * 图的代码实例
 */
public class Graph {

    public static void main(String[] args) {
        //测试
        int n=5;
        String[] VertexValue = {"A", "B", "C", "D", "E"};
        //创建图对象
        Graph graph = new Graph(n);
        //循环的添加节点
        for (String vertex: VertexValue) {
            graph.insertVertex(vertex);
            
        }
        //添加边
        graph.insertEdge(0,1,1);//A-B
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        //显示邻接矩阵
        graph.showGraph();
        //DFS遍历
        System.out.println("DFS遍历图像后：");
        // System.out.println(Arrays.toString(graph.isVisited));
        // System.out.println(graph.vertexList.size());
        // System.out.println(graph.isVisited.length);
        graph.dfs();

    }

    private ArrayList<String> vertexList; //存储顶点的集合
    private int[][] edges;  //存储图对应的邻接矩阵
    private int numOfEdges;
    //定义数组boolean[]，记录某个节点是否被访问
    private boolean[] isVisited;

    //构造器
    public Graph(int n){
        vertexList = new ArrayList<String>(n);
        edges = new int[n][n];
        numOfEdges = 0;
        isVisited = new boolean[edges.length];
    }

    /**
     * 得到一个节点得下标
     * @param index
     * @return 如果存在就返回对应得下标，否则返回-1
     */
    public int getFirstNeighbor(int index){
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j]>0){
                return j;
            }
        }
        return -1;
    }
    //根据邻接节点的下标获得另一个邻接节点
    public int getNextNeighbor(int v1, int v2){
        for (int j = v2+1; j < vertexList.size(); j++) {
            if (edges[v1][j]>0){
                return j;
            }
        }
        return -1;
    }

    //深度优先遍历算法
    private void dfs(boolean[] isVisited, int i){
        //首先我们访问节点，输出
        System.out.println(getValueByIndex(i)+"->");//获取第一个访问节点v
        //将该节点设置为已经访问
        isVisited[i] = true;
        //查找节点v的第一个相邻节点w
        int w = getFirstNeighbor(i);
        //情况1.如果w存在；
        while(w!=-1){
            if (!isVisited[w]){
                dfs(isVisited,w);
            }
            //如果w已经被访问，则查找下一个邻接点
            w = getNextNeighbor(i,w); //实际上i和w是对应节点的下标，并不是节点本身。
        }
    }
    //对于上述的dfs进行重载，以满足w不存在的情况
    public void dfs(){
        //遍历所有的节点，对dfs进行回溯
        for (int i = 0; i < getNumberOfVertex(); i++) {
            if (!isVisited[i]){//若没有被访问，则进入下面的步骤
                dfs(isVisited,i);
            }
        }
    }


    /**
     * 无向图添加边
     * @param v1 表示起始点
     * @param v2 表示终止点
     * @param weight 表示边的权重
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;

    }

    /**
     * 插入节点
     * @param vertex 插入的节点名
     */
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }
    public void showGraph(){
        for (int[] link:edges){
            System.out.println(Arrays.toString(link));
        }

    }

    //返回节点的数目
    public int getNumberOfVertex(){
        return vertexList.size();
    }
    //返回边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回对应下标的值 0-A, 1-B, 2-C
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回某条边的权值
    public int getWeight(int v1, int v2){
        return edges[v1][v2];
    }

}
```

## BFS广度优先算法

类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点顺序，以便按照这个顺序来访问这些节点的邻接节点。

### BFS遍历算法的步骤

<img src="C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220624095503007.png" alt="image-20220624095503007" style="zoom: 200%;" />

以邻接矩阵举例：

1. DFS是从第一行开始，找到第一个节点的邻接节点后到下一行寻找邻接节点的邻接节点
2. BFS是从第一行开始，找到第一个节点的邻接节点后，继续寻找第一个节点的其他的邻接节点。找完后寻找下一行。

### BFS代码实例

```
package Graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

/**
 * @author 巩泽楷
 * @version 1.0
 * 图的代码实例
 */
public class Graph {

    public static void main(String[] args) {
        //测试
        int n=8;
        //String[] VertexValue = {"A", "B", "C", "D", "E"};
        String[] VertexValue = {"1","2","3","4","5","6","7","8"};

        //创建图对象
        Graph graph = new Graph(n);
        //循环的添加节点
        for (String vertex: VertexValue) {
            graph.insertVertex(vertex);

        }
        //添加边
//            图一：
//            graph.insertEdge(0,1,1);//A-B
//            graph.insertEdge(0,2,1);
//            graph.insertEdge(1,2,1);
//            graph.insertEdge(1,3,1);
//            graph.insertEdge(1,4,1);
        //图二
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);
        graph.insertEdge(3,7,1);
        graph.insertEdge(4,7,1);
        graph.insertEdge(2,5,1);
        graph.insertEdge(2,6,1);
        graph.insertEdge(5,6,1);


        //显示邻接矩阵
        graph.showGraph();
        //DFS遍历
        System.out.println("DFS遍历图像后：");
        // System.out.println(Arrays.toString(graph.isVisited));
        // System.out.println(graph.vertexList.size());
        // System.out.println(graph.isVisited.length);
        graph.dfs();
        //System.out.println("BFS遍历图像：");
        //graph.bfs();

    }

    private ArrayList<String> vertexList; //存储顶点的集合
    private int[][] edges;  //存储图对应的邻接矩阵
    private int numOfEdges;
    //定义数组boolean[]，记录某个节点是否被访问
    private boolean[] isVisited;

    //构造器
    public Graph(int n){
        vertexList = new ArrayList<String>(n);
        edges = new int[n][n];
        numOfEdges = 0;
        isVisited = new boolean[edges.length];
    }

    /**
     * 得到一个节点得下标
     * @param index
     * @return 如果存在就返回对应得下标，否则返回-1
     */
    public int getFirstNeighbor(int index){
        for (int j = 0; j < vertexList.size(); j++) {
            if (edges[index][j]>0){
                return j;
            }
        }
        return -1;
    }
    //根据邻接节点的下标获得另一个邻接节点
    public int getNextNeighbor(int v1, int v2){
        for (int j = v2+1; j < vertexList.size(); j++) {
            if (edges[v1][j]>0){
                return j;
            }
        }
        return -1;
    }

    //深度优先遍历算法
    private void dfs(boolean[] isVisited, int i){
        //首先我们访问节点，输出
        System.out.println(getValueByIndex(i)+"->");//获取第一个访问节点v
        //将该节点设置为已经访问
        isVisited[i] = true;
        //查找节点v的第一个相邻节点w
        int w = getFirstNeighbor(i);
        //情况1.如果w存在；
        while(w!=-1){
            if (!isVisited[w]){
                dfs(isVisited,w);
            }
            //如果w已经被访问，则查找下一个邻接点
            w = getNextNeighbor(i,w); //实际上i和w是对应节点的下标，并不是节点本身。
        }
    }
    //对于上述的dfs进行重载，以满足w不存在的情况
    public void dfs(){
        //遍历所有的节点，对dfs进行回溯
        for (int i = 0; i < getNumberOfVertex(); i++) {
            if (!isVisited[i]){//若没有被访问，则进入下面的步骤
                dfs(isVisited,i);
            }
        }
    }

    //对一个节点进行广度优先遍历的方法
    private void bfs(boolean[] isVisited, int i){
        int u; // 表示队列的头节点对应的下标
        int w; // 邻接节点w
        //队列，记录节点访问的顺序
        LinkedList queue = new LinkedList();
        //访问节点，输出节点信息
        System.out.println(getValueByIndex(i)+"-->");
        //标记已经访问
        isVisited[i] = true;
        //将节点加入队列
        queue.addLast(i);

        while(!queue.isEmpty()){
            //取出队列的头节点 下标
            u = (Integer)queue.removeFirst();
            //查找节点u的第一个邻接节点w
            w = getFirstNeighbor(u);
            //判断w是否存在
            while (w!=-1){//存在
                if (!isVisited[w]){
                    System.out.println(getValueByIndex(w)+"-->");
                    //标记已经访问
                    isVisited[w] = true;
                    //入队
                    queue.addLast(w);
                }
                //寻找节点u的邻接节点w的下一个邻接节点w
                w = getNextNeighbor(u,w);
            }

        }
    }

    //遍历所有的节点进行广度优先算法
    public void bfs(){
        for (int i = 0; i < getNumberOfVertex(); i++) {
            if (!isVisited[i]){
                bfs(isVisited, i);
            }
        }
    }


    /**
     * 无向图添加边
     * @param v1 表示起始点
     * @param v2 表示终止点
     * @param weight 表示边的权重
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;

    }

    /**
     * 插入节点
     * @param vertex 插入的节点名
     */
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }
    public void showGraph(){
        for (int[] link:edges){
            System.out.println(Arrays.toString(link));
        }

    }

    //返回节点的数目
    public int getNumberOfVertex(){
        return vertexList.size();
    }
    //返回边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    //返回对应下标的值 0-A, 1-B, 2-C
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    //返回某条边的权值
    public int getWeight(int v1, int v2){
        return edges[v1][v2];
    }

}
```

## DFS和BFS的对比

![image-20220624120013795](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220624120013795.png)

# 算法

## 非递归的二分查找

```
package BinarySearchNoRecurve;

/**
 * @author 巩泽楷
 * @version 1.0
 * 二分查找的非递归实现
 * 
 */
public class BinarySearchNoRecurve {
    public static void main(String[] args) {
        int[] arr = {1,3,8,10,11,67,100};
        int index = binarySearch(arr,-8);
        System.out.println("index="+index);
    }

    /**
     * 二分查找的非递归实现
     * @param arr 待查找的数组
     * @param target 需要查找的数组
     * @return 返回对应的下标，-1表示没有找到
     */
    public static int binarySearch(int[] arr, int target){
        int left = 0;
        int right = arr.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            if (arr[mid]==target){
                return mid;
            } else if (arr[mid]>target){
                right = mid-1;
            } else if (arr[mid]<target){
                left = mid+1;
            }
        }
        return -1;
    }
}
```

## 分治算法

### 分治法基本定义

分治法是一种很重要的算法。主要思想是“分而治之”，就是把一个复杂的问题分解成两个或者更多相同或者类似的子问题。再把子问题分解成更小的子问题求解。直到最后的子问题可以简单的直接求解，原问题的解即是子问题解的合并。

### 分治算法可以求解的经典问题

1. 二分搜索
2. 大整数乘法
3. 合并排序
4. 快速排序
5. 棋盘覆盖
6. 线性时间查找
7. 最接近点对问题
8. 汉诺塔

### 分治算法的基本步骤

1. 分解：将原问题分解成若干规模较小，互相独立，与原问题形式相同的子问题。
2. 解决：若子问题规模较小而容易被解决则直接解，否则递归的求解各个子问题。
3. 合并：将各个子问题的解合并为原问题的解。

### 分治算法解决汉诺塔问题

#### 汉诺塔问题的思想分析

1. 如果有一个盘，A->C

* 如果我们有n>=2的情况，我们总是可以看做是两个盘，1个最下面的盘，2.将除了最底层的盘的其他盘视为另一个盘，即为上面的盘

1. 那么，先把最上面的盘A->B
2. 把最下面的盘A->C
3. 把B塔的所有盘从B->C

## 动态规划

![image-20220627163809903](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220627163809903.png)

### 动态规划解决背包问题

![image-20220628143519079](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220628143519079.png)

### 思路分析和图解

算法的主要思想是利用动态规划来解决。每一次遍历到第i个物品。根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i], w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能能装入容量为j的背包中的最大价值。

![image-20220628144317783](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220628144317783.png)

1. v[i] [0] = v[0] [j] = 0; //表示填入表第一行和第一列是0

2. 当w[i]>j时：v[i] [j] = v[i-1] [j] //当准备加入新增的商品的容量大于当前背包的容量时，直接使用上一个单元格的装入策略。

3. 当j >= w[i]时：v[i] [j] = max{v[i-1] [j] , v[i] + [v-1] [j-w[i]]} //当准备加入的新增的商品的容量小于等于当前背包的容量。

   // 装入方式：v[i-1] [j]: 就是上一个单元格的装入的最大值。 





#### 01背包问题实际案例

![image-20220628150528516](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220628150528516.png)

 ### 背包问题的代码实例

```
package Dynamic;

import com.sun.xml.internal.fastinfoset.tools.XML_SAX_StAX_FI;

/**
 * @author 巩泽楷
 * @version 1.0
 * 01背包问题
 */
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1,3,5}; //表示物品的重量
        int[] val = {1500, 3000, 2000}; //物品价值
        int m = 4; //背包的重量
        int n = val.length; //物品的个数

        //创建二维数组
        //v[i][j] 表示在前i个物品中能够装入容量为j的背包问题
        int[][] v = new int[n+1][m+1];

        //记录放入商品的情况
        int[][] path = new int[n+1][m+1];

        //初始化第一行和第一列，这里在默认为0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0; //将第一行设置为0
        }
        for (int j = 0; j < v[0].length; j++) {
            //v[0].length表示第一列的行的长度
            v[0][j] = 0;
        }

        //进行动态规划处理
        for (int i = 1; i < v.length; i++) {
            for (int j = 1; j <v[0].length; j++) {//不处理第一列，j从1开始
                //公式
                if (w[i-1]>j){//因为i从1开始，w[1]对应的下标是3，需要从1开始
                    v[i][j] = v[i-1][j];
                }else {
                    //因为是从i=1开始，因此公式需要调整,因为没有算0行和0列
                    //v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]])
                    //v[i][j] = Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
                    if (v[i-1][j]<(val[i-1]+v[i-1][j-w[i-1]])){
                        v[i][j] = val[i-1]+v[i-1][j-w[i-1]];
                        //把当前的情况记录在path
                        path[i][j] = i;
                    }else {
                        v[i][j] = v[i-1][j];
                    }
                }
            }
        }
        //输出v
        for (int i = 0; i < v.length; i++) {
            for (int j = 0; j < v[i].length; j++) {
                System.out.print(v[i][j]+" ");
            }
            System.out.println();
        }

    }
}
```

## 暴力匹配算法解决字符串问题

![image-20220628164802290](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220628164802290.png)

### 暴力匹配的代码实例

```
package Violencemath;

/**
 * @author 巩泽楷
 * @version 1.0
 * 暴力匹配算法
 */
public class ViolenceMath {
    public static void main(String[] args) {

    }
    //暴力匹配算法
    public static int violenceMath(String str1, String str2){
        //将String转换为char数组
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int i = 0;
        int j = 0;
        while (i < s1.length && j<s2.length){//保证匹配时不越界
            if (s1[i]==s2[j]){
                i++;
                j++;
            }else { //没有匹配成功
                i = i-(j-1);
                j = 0;
            }
        }
        //判断是否匹配成功
        if (j==str2.length()){
            return i-j;
        }else {
            return -1;
        }
    }
}
```

## KMP算法

### KMP的算法介绍

1. KMP是一个解决模式串在文本串中是否出现过，如果出现过，最早出现的位置的京东算法
2. KMP的算法是利用之前判断过的信息，通过一个next数组，在保存模式串前后最长公共子序列的长度，在每次回溯时，通过next数组找到在这之前匹配过的位置，节省了大量的计算时间。

### 思想分析

#### 匹配值表

![image-20220701120328340](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120328340.png)

#### 实际操作

![image-20220701120440385](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120440385.png)

![image-20220701120501995](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120501995.png)

![image-20220701120527974](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120527974.png)

![image-20220701120632772](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120632772.png)

![image-20220701120753308](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120753308.png)

![image-20220701120821339](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220701120821339.png)

根据前缀和后缀找出匹配值表，再使用匹配值表对不同的比较结果进行移动。

### KMP代码实例

```
package KMP;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 * KMP算法
 */
public class KMP {
    public static void main(String[] args) {
        //
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] next = kmpNext("ABCDABD");
        System.out.println("next="+ Arrays.toString(next));
        int index = kmpSearch(str1,str2,next);
        System.out.println("index="+index);
    }
    /**
     * KMP搜索算法
     * @param str1 源字符串
     * @param str2 子串
     * @param next 部分匹配表， 是子串对应的部分匹配表
     * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置。
     */
    public static int kmpSearch(String str1, String str2, int[] next){
        //遍历
        for (int i = 0, j=0; i < str1.length(); i++) {
            while (j>0&&str1.charAt(i)!=str2.charAt(j)){
                j = next[j-1];
            }
            //
            if (str1.charAt(i)==str2.charAt(j)){
                j++;
            }
            if (j == str2.length()){
                return i-j+1;
            }
        }
        return -1;
    }
    //获取一个子字符串的部分匹配值表
    public static int[] kmpNext(String dest){
        //创建一个next数组来存储部分匹配值
        int[] next = new int[dest.length()];
        //情况1： str2只有一个单位
        next[0] = 0;
        for (int i = 1, j = 0; i < dest.length(); i++) {
            //直到dest.charAt(i) != dest.charAt(j), 我们需要从next[j-1]获取新的j
            //这是KMP算法的核心问题
            while(j>0&&dest.charAt(i)!=dest.charAt(j)){
                j = next[j-1];
            }
            //dest.charAt(i) == dest.charAt(j)满足时，部分匹配值加1
            if (dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
```

## 贪心算法

1. 贪心算法是指在对问题进行求解时，在每一步的选择中都采用最好或者最优的选择，从而希望能够导致结果是最好或者最优的算法。
2. 贪心算法所得到的结果不一定是最优的结果（有时可能是最优解），但都是相对近似的最优解的结果。

### 贪心算法解决集合覆盖问题

![image-20220702164213130](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220702164213130.png)

![image-20220702164327737](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220702164327737.png)

放入顺序K1-K2-K3-K5



#### 代码实例

```
package Greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

/**
 * @author 巩泽楷
 * @version 1.0
 * 贪心算法解决集合覆盖问题
 */
public class GreedyAlgorithm {
    public static void main(String[] args) {
        //创建广播电台。
        HashMap<String, HashSet<String>> broadCasts = new HashMap<String, HashSet<String>>();
        //将各个电台放入broadCasts
        //第一组
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        //第二组
        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        //第三组
        HashSet<String> hashSet3= new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        //第四组
        HashSet<String> hashSet4= new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");
        //第五组
        HashSet<String> hashSet5= new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到map中
        broadCasts.put("K1",hashSet1);
        broadCasts.put("K2",hashSet2);
        broadCasts.put("K3",hashSet3);
        broadCasts.put("K4",hashSet4);
        broadCasts.put("K5",hashSet5);

        //存放所有的地区
        HashSet<String> allAreas = new HashSet<String>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");

        //创建一个集合类ArrayList， 存放选择的电台集合
        ArrayList<String> selects = new ArrayList<String>();

        //定义一个临时的集合，在遍历过程中，存放遍历过程中的电台覆盖的地区和没有覆盖的地区
        HashSet<String> tempSet = new HashSet<String>();

        //
        String maxKey = null;
        while(allAreas.size()!=0){//不为0，不结束
            maxKey = null; //每一次循环需要将maxKey制空

            //遍历broadcasts
            for (String key : broadCasts.keySet()) {//根据返回每个key对应的key值
                tempSet.clear();
                //当前这key能够覆盖的地区
                HashSet<String> areas = broadCasts.get(key);
                tempSet.addAll(areas);
                //求tempSet和allAreas的交集
                tempSet.retainAll(allAreas);//retainAll求交集的方法：计算tempSet和retainAll的交集，并把交集赋给tempSet
                //如果当前集合包含的未覆盖地区的数量，比maxKey指向的集合地区还要多
                //就需要重置maxKey
                if (tempSet.size()>0 && (maxKey == null || tempSet.size()>broadCasts.get(maxKey).size())){
                    maxKey = key;
                }
            }
            //maxKey != null, 就应该将maxKey加入selects
            if (maxKey!=null){
                selects.add(maxKey);
                //将maxKey指向的广播覆盖地区，进行清除
                allAreas.removeAll(broadCasts.get(maxKey));
            }
        }

        System.out.println("得到的结果是"+selects);


    }
}
```



## Prim算法

### prim的应用场景

#### 修路问题（旅行商问题）最小生成树问题

![image-20220703144231893](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220703144231893.png)

<font color='red'>该问题可以修正为最小生成树问题</font>

 ![image-20220703144650122](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220703144650122.png)

### Prim算法的介绍

1. Prim算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含的n个顶点的连通图，也就是所谓的<font color=blue>极小连同子图</font>

2. Prim算法细节如下：

   1. 设G=(V, E)是连通图，T=(U, D)是最小生成树， V和U是顶点集合，E,D是边的集合。
   2. 若从顶点u开始构建最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1。
   3. 若集合U中的顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中的权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui, vi)加入到集合D中，标记为visited[vj] = 1
   4. 重复步骤b，直到U和V相等，即所有的节点都被访问过，此时D有n-1条边。

   

![image-20220704175851921](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220704175851921.png)

## Kruskal算法克鲁斯卡尔算法

### Kruskal的基本介绍

1. Kruskal算法是用来求加权图的最小生成树的算法
2. 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。
3. 具体做法：首先构建一个只含有n个顶点的森林，然后以权值从小到大从连同网中选择具体边加入到森林中，并使这个森林不产生回路

### 实例解析

<font color='red'>寻找最短且不构成回路的边</font>

<font color='red'>我们加入边的两个顶点不能都指向同一个终点，否则将构成回路。</font>

![image-20220705111734687](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220705111734687.png)

![image-20220705111850662](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220705111850662.png)

![image-20220705112028943](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220705112028943.png)

### Kruskal算法的实际案例与代码解析

![image-20220705113519444](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220705113519444.png)

```
package Kruskal;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class KruskalCase {
    private int edgeNum; //边的个数
    private char[] vertex; //顶点的数组
    private int[][] matrix; //邻接矩阵
    //使用INF表示两个顶点不能连通。
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        char[] vertex = {'A','B','C','D','E','F','G'};
        int matrix[][] = {
                {0,12,INF,INF,INF,16,14},
                {12,0,10,INF,INF,7,INF},
                {INF,10,0,3,5,6,INF},
                {INF,INF,3,0,4,INF,INF},
                {INF,INF,5,4,0,2,8},
                {16,7,6,INF,2,0,9},
                {14,INF,INF,INF,8,9,0}
        };
        //创建对象
        KruskalCase kruskalCase = new KruskalCase(vertex,matrix);
        //输出构建
        kruskalCase.print();
        EData[] edges = kruskalCase.getEdges();
        System.out.println("没有排序的边的集合："+ Arrays.toString(kruskalCas
        kruskalCase.sortEdges(edges);
        System.out.println("已经排序的边的集合："+ Arrays.toString(edges));
        kruskalCase.kruskal();

    }
    //构造器
    public KruskalCase(char[] vertex, int[][] matrix){
        //初始化顶点和边的个数
        int vlen = vertex.length;
        //初始化顶点，复制拷贝的方式
        this.vertex = new char[vlen];
        for (int i = 0; i < vlen; i++) {
            this.vertex[i] = vertex[i];
        }

        //初始化边, 使用的是复制拷贝的方式
        this.matrix = new int[vlen][vlen];
        for (int i = 0; i < vlen; i++) {
            for (int j = 0; j < vlen; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
        //统计边
        for (int i = 0; i < vlen; i++) {
            for (int j = i+1; j < vlen; j++) {
               if ( this.matrix[i][j] != INF){
                   edgeNum++;
               }
            }
        }
    }

    //
    public void kruskal(){
        int index = 0;//表示结果数组有多少条边
        int[] ends = new int[edgeNum];//用于保存已经存在的生成树中的每个顶点在最小的生成树的终
        //创建结果数组
        EData[] rets = new EData[edgeNum];
        //获取图中所有边的集合
        EData[] edges = getEdges();
        //System.out.println("图的边的集合="+Arrays.toString(edges)+"共"+e

        //按照边的权值大小进行排序
        sortEdges(edges);//从小到大

        //遍历edges数组，将最小的边加入到MIT中，判断准备加入的边是否形成了回路，如果没有就加入rets数组
        for (int i = 0; i < edgeNum; i++) {
            //获取第i条边的第一个顶点
            int p1 = getPosition(edges[i].start);
            //获取第i条边的第二个顶点
            int p2 = getPosition(edges[i].end);

            //获取p1这个顶点在已有最小生成树的终点
            int m = getEnd(ends,p1);
            //获取p2这个顶点在最小生成树中的终点
            int n = getEnd(ends,p2);
            //是否构成回路，此时的起点与终点，指的是是否构成回路的起点和终点。
            if (m!=n){
                ends[m] = n;//设置m
                rets[index++] = edges[i]; //有一条边加入到rets数组
            }
        }

        //统计并打印最小生成树
        System.out.println("最小生成树为= "+ Arrays.toString(rets));


    }

    //打印邻接矩阵
    public void print(){
        System.out.println("邻接矩阵为：\n");
        for (int i = 0; i < vertex.length; i++) {
            for (int j = 0; j < vertex.length; j++) {
                System.out.printf("%12d",matrix[i][j]);
            }
            System.out.println();
        }
    }

    //使用冒泡排序对边进行排序
    private void sortEdges(EData[] edges){//elen为对应的长度
        for (int i = 0; i < edges.length-1; i++) {
            for (int j = 0; j < edges.length - 1 - i; j++) {
                if (edges[j].weight>edges[j+1].weight){
                    EData temp = edges[j];
                    edges[j] = edges[j+1];
                    edges[j+1] = temp;
                }
            }
        }
    }

    /**
     * 返回顶点对应的下标
     * @param ch 顶点的值，比如‘A’，‘B’
     * @return
     */
    private int getPosition(char ch){
        for (int i = 0; i < vertex.length; i++) {
            if (vertex[i]==ch){
                return i;
            }
        }
        //找不到返回-1
        return -1;
    }

    /**
     *
     * @return
     */
    private EData[] getEdges(){
        int index = 0;
        EData[] edge = new EData[edgeNum];
        for (int i = 0; i < vertex.length; i++) {
            for (int j = i+1; j < vertex.length; j++) {
                if (matrix[i][j]!=INF){
                    edge[index++] = new EData(vertex[i],vertex[j],m
                }
            }
        }
        return edge;
    }

    /**
     * 功能:获取下标为i的顶点的终点，用于判断两个顶点的终点是否相同
     * @param ends 记录了各个顶点对应终点的数组
     * @param i 传入顶点对应的下标
     * @return 返回的就是下标为i的这个顶点对应的终点的下标
     */
    private int getEnd(int[] ends, int i){
        while (ends[i]!=0){
            i = ends[i];
        }
        return i;
    }

}

//边的类
class EData{
    char start; //边的起点
    char end;   //边的终点
    int weight; //边的权值

    //构造器
    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //重写toString方法

    @Override
    public String toString() {
        return "EData<" +
                 start +
                "," + end +
                ">=" + weight
                ;
    }
}
```



## Dijkstra算法 迪杰斯特拉算法

### 最短路径问题

![image-20220707195821117](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220707195821117.png)

<font color='red'>注意是点与点之间的最短路径问题</font> 比如有A,B,C,D,E五个点，求A-E的最短路径

###  Dijkstra算法的过程

设置出发点v, 顶点集合V[v1,v2,v3.....vi]，v到V中各项顶点的距离构成距离集合Dis，Dis[d1,d2,d3.....], Dis集合记录着v到图中各个顶点的距离(到自身可以看作0， v到vi的距离对应为di)

1. 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的点vi，此时的v到vi即为最短路径距离。
2. 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)
3. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束。

![image-20220708100529082](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220708100529082.png)

### Dijkstra代码实例

```
package Dijkstra;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class DijkstraAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A','B','C','D','E','F','G'};
        //邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535; //表示不可以连接
        matrix[0]=new int[]{N,5,7,N,N,N,2};
        matrix[1]=new int[]{5,N,N,9,N,N,3};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,3,N,N,4,6,N};
        //创建Graph对象
        Graph graph = new Graph(vertex,matrix);
        graph.showGraph();
        //测试Dijkstra算法
        graph.dsj(6);//以G为起始点
        graph.showDijkstra();


    }

}

class Graph{
    private char[] vertex;  //顶点数组
    private int[][] matrix; //邻接矩阵
    private VisitedVertex vv;

    public Graph(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }

    //显示图的方法
    public void showGraph(){
        for (int[] link : matrix) {
            System.out.println(Arrays.toString(link));
        }
    }

    public void showDijkstra(){
        vv.show();
    }

    //Dijkstra算法的实现
    public void dsj(int index){
        vv = new VisitedVertex(vertex.length, index);
        //确定初始点
        update(index); //更新index顶点到周围顶点的距离和前驱顶点


        for (int i = 1; i < vertex.length; i++) {
            index = vv.updateArr();//确定下一个初始点
            update(index); // 更新index顶点到周围顶点的距离和前驱顶点
        }
    }




    //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点
    private void update(int index){
        int len = 0;
        //根据遍历我们的邻接矩阵的matrix[index]
        for (int i = 0; i < matrix[index].length; i++) {
            //len的含义是：出发顶点到index顶点的距离+从index顶点到j顶点的距离
            len = vv.getDis(index)+matrix[index][i];
            //如果j顶点没有被访问过，并且len小于出发顶点到j顶点的距离，则需要更新
            if (!vv.in(i)&&len<vv.getDis(i)){
                vv.updatePre(i,index);//更新j的顶点为前驱顶点
                vv.updateDis(i,len);//更新出发顶点到j顶点的距离
            }
        }
    }
}

//已经访问的顶点的集合

class VisitedVertex{
    //记录各个顶点是否被访问过，1表示访问过，0表示未访问，动态更新
    public int[] already_arr;
    //每个下标对应的值为前一个顶点的下标
    public int[] pre_visited;
    //记录出发顶点到其他所有顶点的距离，比如从G为出发点，就会记录G到其他顶点的距离，会动态更新，得出的最小距离会被放到dis中。
    public int[] dis;

    /**
     * 构造器
     * @param length 表示顶点的个数
     * @param index 出发顶点对应的下标，比如G顶点下标为6
     */
    public VisitedVertex(int length, int index){
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];
        //初始化 dis数组
        Arrays.fill(dis,65535);
        this.dis[index] = 0; //设置出发顶点访问距离为0
        this.already_arr[index] = 1;//设置出发顶点被访问过


    }

    /**
     * 功能：判断index顶点是否被访问过
     * @param index
     * @return 如果访问过，返回true，没有则false
     */
    public boolean in(int index){
        return already_arr[index] == 1;

    }

    /**
     * 功能：更新出发顶点到index顶点的距离
     * @param index
     * @param len
     */
    public void updateDis(int index, int len){
        dis[index] = len;
    }

    /**
     * 功能：更新前驱节点为index的顶点
     * @param pre
     * @param index
     */
    public void updatePre(int pre, int index){
        pre_visited[pre] = index;
    }

    /**
     * 功能：返回出发顶点到index顶点的距离
     * @param index
     */
    public int getDis(int index){
        return dis[index];
    }

    //继续访问并返回新的访问节点，比如在G访问完成之后，就是A点作为新的访问节点
    //更新新的节点
    public int updateArr(){
        int min = 65535;
        int index = 0;
        for (int i = 0; i < already_arr.length; i++) {
            if (already_arr[i] == 0 && dis[i]<min){
                min = dis[i];
                index = i;
            }
        }
        //更新index顶点，使其被访问过
        already_arr[index] = 1;
        return index;
    }

    //显示最后的结果
    //打印三个数组
    public void show(){
        System.out.println("=====================================");
        //输出already_arr
        System.out.println("already_arr: ");
        for (int i :already_arr) {
            System.out.print(i+" ");
        }
        System.out.println();
        //输出pre_visited
        System.out.println("pre_visited: ");
        for (int i :pre_visited) {
            System.out.print(i+" ");
        }
        System.out.println();
        //输出dis
        System.out.println("dis: ");
        for (int i :dis) {
            System.out.print(i+" ");
        }
    }
}
```



## Floyed 算法 弗洛伊德算法

1. 一种通过给定的加权图中的顶点来计算的最短路径的算法

![image-20220709164446072](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220709164446072.png)

解释一下关于最短路径的问题：

<font color='red'>如果以A为起始点，则会计算从A到B，C，D，E，F，G点的最短路径。之后再以B为起始点再次进行计算，得出B到各个点的最短路径，以此类推。</font>

### Floyed算法的图解分析

1. 设置顶点vi到顶点vk的最短路径为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi的路径为Lij，则vi到vj的最短路径为：min(Lik+Lkj), vk的取值为图中所有顶点，则可以获得vi到vj的最短路径。
2. 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得的。

![image-20220709212901039](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220709212901039.png)

### Floyed实例分析

![image-20220709213202200](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220709213202200.png)

<font size=5>**初始的前驱关系**</font>

![image-20220709213333876](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220709213333876.png)

<font size=5> Floyed 算法的步骤</font>

**第一步：**

在第一轮循环中，<font color='red'>以A(下标为：0)作为中间顶点</font>【即把A作为中间顶点的所有情况都进行遍历，就会得到新得距离表和前驱关系】，更新后得图标如下：

![image-20220709214125843](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220709214125843.png)

**第二步：**

以B进行如A的上述操作

### Folyed算法的实现

* 创建三个char[]，分别为中间顶点，出发顶点，终点。三个char[]都为A,B,C,D,E,F,G
* 建立三个for循环，当A为中间顶点，A为出发顶点，A为终点，判断是否存在，如果不存在，再进行下一次循环，如果存在，记录距离大小，再进行下一次循环。当A为中间顶点，A为出发顶点，B为终点。依次类推。。。最终找到到各个点距离的最小值。

```
package Floyed;

import java.util.Arrays;

/**
 * @author 巩泽楷
 * @version 1.0
 */
public class FloydAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A','B','C','D','E','F','G'};
        //创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[]{0,5,7,N,N,N,2};
        matrix[1] = new int[]{5,0,N,9,N,N,2};
        matrix[2] = new int[]{7,N,0,N,8,N,N};
        matrix[3] = new int[]{N,9,N,0,N,4,N};
        matrix[4] = new int[]{N,N,8,N,0,5,4};
        matrix[5] = new int[]{N,N,N,4,5,0,6};
        matrix[6] = new int[]{2,3,N,N,4,6,0};

        //创建Graph对象
        Graph graph = new Graph(vertex.length, matrix, vertex);
        graph.show();
        //调用Floyd算法
        graph.floyd();
        graph.show();

    }
}
//创建图
class Graph{
    private char[] vertex; //存放顶点的数组
    private int[][] dis; //保存从各个顶点出发到其他顶点的距离
    private int[][] pre; //保存到达目标顶点的前驱顶点

    //构造器
    public Graph(int length, int[][] matrix, char[] vertex){  //matrix为邻接矩阵,即为dis。
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];

        //初始化 pre中存放的是前驱顶点的下标
        for (int i = 0; i < length; i++) {
            Arrays.fill(pre[i],i);
        }
    }

    //显示pre数组和dis数组
    public void show(){
        //显示pre数组
        System.out.println("Pre数组：");
        for (int k = 0; k < dis.length ; k++) {
            for (int i = 0; i < dis.length; i++) {
                System.out.print(vertex[pre[k][i]]+" ");
            }
            System.out.println();
        }
        System.out.println();
        //显示dis数组
        System.out.println("Dis数组：");
        for (int k = 0; k < dis.length; k++) {
            for (int i = 0; i < dis.length; i++) {
                System.out.printf("%6d", dis[k][i]);
            }
            System.out.println();
        }
    }

    //Floyd算法
    public void floyd(){
        int len = 0; //变量保存距离
        //对中间顶点的遍历, k是中间顶点的下标[A,B,C,D,E,F,G]
        for (int k = 0; k < dis.length; k++) {
            //从顶点i开始出发[A,B,C,D,E,F,G]
            for (int i = 0; i < dis.length; i++) {
                for (int j = 0; j < dis.length; j++) {
                    len = dis[i][k]+dis[k][j]; //=> 求出从i顶点出发，经过k中间顶点后，到达j顶点的距离
                    if (len<dis[i][j]){
                        len = dis[i][k] + dis[k][j];
                        if (len<dis[i][j]){//
                            dis[i][j] = len; //更新距离
                            pre[i][j] = pre[k][j]; //更新前驱节点。
                        }
                    }
                }
            }
        }
    }
}
```



## 马踏棋盘算法（骑士周游问题）

![image-20220711162938264](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220711162938264.png)

### 骑士周游问题的解决步骤和思路

1. 创建棋盘chessBoard，这是一个二维数组
2. 将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走那些位置，并放入到一个集合中ArrayList，最多有8个位置。
3. 遍历ArrayList中存放的所有位置，看看那个可以走通。
4. 判断马儿是否完成了任务，step和应该走的步数进行比较，如果没有达到数量，则表示没有完成任务，将整个棋盘置0.

### 骑士周游问题的代码实例（没有使用贪心算法）

```
package Horse;

import java.awt.*;
import java.util.ArrayList;

/**
 * @author 巩泽楷
 * @version 1.0
 * 骑士周游问题
 */
public class HorseChess {
    private static int X; //棋盘的列数
    private static int Y; //棋盘的行数
    //创建一个用于记录棋盘的各个位置是否被访问过的数组
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置是否都被访问过
    private static  boolean finished;
    //

    public static void main(String[] args) {
        System.out.println("骑士周游算法开始运行---");
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        //初始位置
        int row = 1;
        int column = 1;
        //创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X*Y]; //初始值为false
        //测试之前的时间
        long start = System.currentTimeMillis();
        //System.out.println(start);
        traversalChessboard(chessboard, row-1, column-1, 1);
        long end = System.currentTimeMillis();
        System.out.println("共用时间："+(end-start)+"毫秒");

        //输出棋盘的最后情况
        for (int[] rows :chessboard) {
            for (int step :rows) {
                System.out.print(step+"\t");
            }
            System.out.println();
        }


    }

    /**
     * 完成骑士周游算法
     * @param chessboard 棋盘
     * @param row 马当前的行
     * @param column 马当前的列
     * @param step 第几步，初始位置是第一步
     * 这种方法并不一定是最优解，因为人为规定了位置的选择顺序。
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step){
        chessboard[row][column] = step;
        visited[row*X+column] = true; //因为visited[]是一个一维数组，所有按照从上到下将二维数组拉成一个一维数组就好。
        //获取当前位置可以走的下一个集合
        ArrayList<Point> ps = next(new Point(row, column));
        //遍历ps
        while(!ps.isEmpty()){
            Point p = ps.remove(0);
            //判断该点是否放问过
            if (!visited[p.x*X+p.y]){//没有访问过
                traversalChessboard(chessboard,p.x,p.y,step+1);
            }
        }
        //判断马是否完成这个任务
        if (step<X*Y && !finished){
            chessboard[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }


    }

    /**
     * 功能：根据当前的位置，计算马接下来还能走那些位置，最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        //创建一个ArrayList
        ArrayList<Point> point_list = new ArrayList<Point>();
        //创建一个Point
        Point point = new Point();
        //判断是否可以走周围的8个点
        //第1个
        if ((point.x=curPoint.x-2)>=0 && (point.y = curPoint.y-1)>=0){
            point_list.add(new Point(point));
        }
        //第2个
        if ((point.x=curPoint.x-1)>=0 && (point.y = curPoint.y-2)>=0){
            point_list.add(new Point(point));
        }
        //第3个
        if ((point.x=curPoint.x+1)<X && (point.y = curPoint.y-2)>=0){
            point_list.add(new Point(point));
        }
        //第4个
        if ((point.x=curPoint.x+2)<X && (point.y = curPoint.y-1)>=0){
            point_list.add(new Point(point));
        }
        //第5个
        if ((point.x=curPoint.x+2)<X && (point.y = curPoint.y+1)<Y){
            point_list.add(new Point(point));
        }
        //第6个
        if ((point.x=curPoint.x+1)<X && (point.y = curPoint.y+2)<Y){
            point_list.add(new Point(point));
        }
        //第7个
        if ((point.x=curPoint.x-1)>=0 && (point.y = curPoint.y+2)<Y){
            point_list.add(new Point(point));
        }
        //第8个
        if ((point.x=curPoint.x-2)>=X && (point.y = curPoint.y+1)<Y){
            point_list.add(new Point(point));
        }

        return point_list;

    }
}
```

### 骑士周游问题(贪心算法)

使用贪心算法对原来的算法进行优化。原理是一般选择可走步数最少的数组可以减少计算次数。

1. 获取当前位置可以走的下一个位置的集合
2. 对ps中所有的point的下一步的所有集合的数目进行非递减排序。
   1. 非递减：不依次递减的排序

```
package Horse;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;

/**
 * @author 巩泽楷
 * @version 1.0
 * 骑士周游问题
 */
public class HorseChess {
    private static int X; //棋盘的列数
    private static int Y; //棋盘的行数
    //创建一个用于记录棋盘的各个位置是否被访问过的数组
    private static boolean visited[];
    //使用一个属性，标记是否棋盘的所有位置是否都被访问过
    private static  boolean finished;
    //

    public static void main(String[] args) {
        System.out.println("骑士周游算法开始运行---");
        //测试骑士周游算法是否正确
        X = 8;
        Y = 8;
        //初始位置
        int row = 1;
        int column = 1;
        //创建棋盘
        int[][] chessboard = new int[X][Y];
        visited = new boolean[X*Y]; //初始值为false
        //测试之前的时间
        long start = System.currentTimeMillis();
        //System.out.println(start);
        traversalChessboard(chessboard, row-1, column-1, 1);
        long end = System.currentTimeMillis();
        System.out.println("共用时间："+(end-start)+"毫秒");

        //输出棋盘的最后情况
        for (int[] rows :chessboard) {
            for (int step :rows) {
                System.out.print(step+"\t");
            }
            System.out.println();
        }


    }

    /**
     * 完成骑士周游算法
     * @param chessboard 棋盘
     * @param row 马当前的行
     * @param column 马当前的列
     * @param step 第几步，初始位置是第一步
     * 这种方法并不一定是最优解，因为人为规定了位置的选择顺序。
     */
    public static void traversalChessboard(int[][] chessboard, int row, int column, int step){
        chessboard[row][column] = step;
        visited[row*X+column] = true; //因为visited[]是一个一维数组，所有按照从上到下将二维数组拉成一个一维数组就好。
        //获取当前位置可以走的下一个集合
        ArrayList<Point> ps = next(new Point(row, column));

        //使用贪心算法对ps进行排序
        sort(ps);

        //遍历ps
        while(!ps.isEmpty()){
            Point p = ps.remove(0);
            //判断该点是否放问过
            if (!visited[p.x*X+p.y]){//没有访问过
                traversalChessboard(chessboard,p.x,p.y,step+1);
            }
        }
        //判断马是否完成这个任务
        if (step<X*Y && !finished){
            chessboard[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }


    }

    /**
     * 功能：根据当前的位置，计算马接下来还能走那些位置，最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        //创建一个ArrayList
        ArrayList<Point> point_list = new ArrayList<Point>();
        //创建一个Point
        Point point = new Point();
        //判断是否可以走周围的8个点
        //第1个
        if ((point.x=curPoint.x-2)>=0 && (point.y = curPoint.y-1)>=0){
            point_list.add(new Point(point));
        }
        //第2个
        if ((point.x=curPoint.x-1)>=0 && (point.y = curPoint.y-2)>=0){
            point_list.add(new Point(point));
        }
        //第3个
        if ((point.x=curPoint.x+1)<X && (point.y = curPoint.y-2)>=0){
            point_list.add(new Point(point));
        }
        //第4个
        if ((point.x=curPoint.x+2)<X && (point.y = curPoint.y-1)>=0){
            point_list.add(new Point(point));
        }
        //第5个
        if ((point.x=curPoint.x+2)<X && (point.y = curPoint.y+1)<Y){
            point_list.add(new Point(point));
        }
        //第6个
        if ((point.x=curPoint.x+1)<X && (point.y = curPoint.y+2)<Y){
            point_list.add(new Point(point));
        }
        //第7个
        if ((point.x=curPoint.x-1)>=0 && (point.y = curPoint.y+2)<Y){
            point_list.add(new Point(point));
        }
        //第8个
        if ((point.x=curPoint.x-2)>=0 && (point.y = curPoint.y+1)<Y){
            point_list.add(new Point(point));
        }

        return point_list;
    }

    //使用贪心算法进行优化
    public static void sort(ArrayList<Point> ps){
        ps.sort(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                //获取o1的下一步的所有点的位置
                int count1 = next(o1).size();
                int count2 = next(o1).size();
                if (count1<count2){
                    return -1;
                }else if (count1==count2){
                    return 0;
                }else {
                    return 1;
                }
            }
        });
    }

}
```







# 其他

## while和do while循环之间的区别 **(**Difference between while and do while Loop**)**

![image-20220324114517984](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220324114517984.png)

## 增强for循环

![image-20220426112840894](C:\Users\白木-泽\AppData\Roaming\Typora\typora-user-images\image-20220426112840894.png)
